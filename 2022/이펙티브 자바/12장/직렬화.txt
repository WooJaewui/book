
 직렬화.



 # 자바 직렬화의 대안을 찾으라.

직렬화의 문제점.
- 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다.

가젯 gadget.
- 라이브러리에서 직렬화 가능 타입들을 연구하여 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수정하는 메서드.

직렬화의 위험을 피하는 방법.
- 아무것도 역직렬화하지 않는 것. ( 사용하지 않아도 된다 )
	- 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많다.
	- 자바 직렬화의 여러 위험을 회피하면서 다양한 플랫폼 지원, 우수한 성능 등의 이점을 제공한다.

역직렬화 필터링.
- 자바 9에 추가됨.
- 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다.
- 화이트리스트, 블랙리스트 방식이 있다.
	- 블랙리스트 : 기록된 잠재적으로 위험한 클래스들을 거부한다.
	- 화이트리스트 : 기록된 안전하다고 알려진 클래스들만 수용한다. ( 이펙티브 자바 추천 )

정리.
- 직렬화는 위험하니 피해야 한다.
- 시스템을 밑바닥부터 설계한다면 JSON이나 프로토콜 버퍼 같은 대안을 사용하자.
- 신뢰할 수 없는 데이터는 역직렬화하지 말자.
- 꼭 사용해야 한다면 역직렬화 필터링을 사용하자.



 # Serializable을 구현할지는 신중히 결정하라.

Serializable 구현의 문제점.
- Serialiazble을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
- private 변수들도 API로 공개되기 때문에 캡슐화가 깨진다.
- 버그와 보안 구멍이 생길 위험이 높아진다.
	- 객체는 생성자를 통해 만드는 것이 기본인데, 직렬화는 다른 방법으로 객체를 생성한다.
- 해당 클래스의 신 버전을 릴리스할 때 테스트할 것이 늘어난다.
	- 신버전과 구버전이 호환이 가능한지 확인해야 된다.

주의사항.
- 상속용으로 설계된 클래스와 인터페이스는 Seerializable을 확장해서는 안 된다. ( 항상 그런건 아님 )
	- Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 경우에는 사용해도 된다.
- 내부 클래스는 직렬화를 구현하지 말아야 한다.
	- 정적 멤버 클래스는 Serializable을 구현해도 된다.



 # 커스텀 직렬화 형태를 고려해보라.

고민사항.
- 먼저 고민해보고 괜찮다고 판달될 때만 기본 직렬화 형태를 사용하라.
	- 직접 설계하더라도 기본 직렬화 형태와 거의 같은 결과가 나올 경우에만 기본 형태를 써야 한다.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
	- 기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 있다.

객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화를 사용할 때 문제점.
1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
	- private 변수들도 공개된다.
2. 너무 많은 공간을 차지할 수 있다.
	- 표현하지 않아도 될 부분까지 직렬화 시킬 경우 디스크 저장이나 전송속도면에서 떨어진다.
3. 시간이 너무 많이 걸릴 수 있다.
	- 저장 데이터에 그래프 위상 정보가 없기 때문에 데이터를 직접 순회하면서 확인할 수 밖에 없다.
4. 스택 오버플로우를 일으킬 수 있다.

transient.
- Serialize하는 과정에 제외하고 싶은 경우 선언하는 키워드.
	- 패스워드와 같은 보안정보를 직렬화 과정에서 제외하고 싶은 경우에 적용.
	- 다양한 이유로 데이터를 전송 하고 싶지 않을 때 선언할 수 있다.

transient 예시.
class Member implements Serializable { 
	private transient String name ;	
	...
}

transient 주의사항.
- 적용하는 Data에 대해 이해가 필요하다.
	- transient한 변수가 없을 때 발생할 수 있는 문제 등.

writeObject, readObject.
- 기본적인 자바 직렬화 또는 역직렬화 과정에서 별도의 처리가 필요한 경우 두 메서드를 클래스 내부에 선언해준다.
- Serializable 인터페이스를 구현한 직렬화 대상 클래스여야 한다.
- 직렬화 과정에서 writeObject, 역직렬화 과정에서 readObject 메서드가 자동으로 호출된다.
- 접근 제어자를 private으로 선언해야 한다.
	- 다른 접근 제어자로 설정하는 경우 호출되지 않는다.
	- 서브 클래스에서 메서드를 재정의하지 못한다. ( 무결성 유지 )
	- 직렬화 과정에서는 리플렉션을 통해 메서드를 호출하기 때문에 문제 없이 수행된다.


defaultWriteObject, defaultReadObject.
- writeObject, readObject 메서드 수행시 가장 먼저 실행해야 되는 메서드.
- transient가 아닌 모든 필드가 직렬화/역직렬화 된다.
- 모든 필드가 transient면 수행하지 않아도 되지만, 추후에 확장될 필드를 위해 작성하는 것이 좋다.

직렬화 주의사항.
- 객체의 전체 상태를 읽는 메서드에 적용 해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
- 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
	- 성능도 조금 빨라지고, UID가 일으키는 잠재적인 호환성 문제가 사라진다.
	- 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 UID를 절대 수정하지 말자.



 # readObject 메서드는 방어적으로 작성하라.

주의사항.
- 객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적으로 복사해야 한다.

기본 readObject 메서드를 사용 여부 판단 기준.
- transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 생성자를 추가해도 괜찮은 경우.
- final이 아닌 직렬화 가능 클래스라면 readObject 메서드에서 재정의 가능 메서드를 호출해서는 안 된다.

정리.
- readObject 메서드를 작성할 때는 항상 public 생성자를 작성하는 자세로 임해야 한다.
- readObject는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 한다.
- 바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해서는 안 된다. ( 변형된 인스턴스가 올 수 있다 )
- private이어야 하는 객체 참조 필드가 각 필드가 가리키는 객체를 방어적으로 복사하라. ( 불변 클래스의 가변 요소 )
- 모든 불변식을 검사하여 어긋나는 게 발견되면 InvalidObjectException을 던져라.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용하라.
- 직접적이든 간접적이든, 재정의할 수 있는 메서드는 호출하지 말자.



 # 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라.

역직렬화에서 싱글톤 유지하는 방법.
1. readResolve 메서드를 통해 역직렬화 후에 다른 값을 반환하게 만들 수 있다. ( 싱글톤 변수를 return )
	- readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.
2. 참조 변수를 Enum으로 만든다.

문제가 발생하는 이유.
- 역직렬화 과정에서 순간적으로 인스턴스에 접근할 수 있게 된다. ( 새로운 메서드를 정의한 경우 문제가 발생할 수 있다 )
- ENUM으로 정의하면 이 문제를 해결할 수 있다.

정리.
- 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하자.
- 여의치 않은 상황에서 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve 메서드를 작성하고, 모든 참조 타입 인스턴스는 transient로 선언.



 # 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라.

직렬화 프록시.
- private static 외부 클래스를 만든다.
- 생성자는 하나만 만드며, 매개변수로 바깥 클래스를 받아야 한다.
- 바깥 클래스와 직렬화 클래스는 모두 Serilizable을 구현한다고 선언.

writeReplace 메서드 예시.
private Object writeReplace( ) {
	return new SerializationProxy( this ) ;
}

직렬화 프록시 패턴의 한계점.
1. 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
2. 객체 그래프의 순환이 있는 클래스에는 적용할 수 없다.
3. 방어적 복사 때보다 성능이 떨어진다.

정리.
- 제3자가 확장할 수 없는 클래스라면 가능한 한 직렬화 프록시 패턴을 사용하자.
- 중요한 불변식을 안정적으로 직렬화해주는 가장 쉬운 방법일 것이다.
























