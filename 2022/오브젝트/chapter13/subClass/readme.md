
# 서브클래싱과 서브타이핑.

--------------------------------------------------------------------------------------------------------------

> ## 타입.

### 상속의 두 가지 용도.
1. 타입 계층을 구현한다.
   - 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
   - 타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화이다.
2. 코드 재사용.
   - 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있다.
   - 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확률이 높다.

### 상속 사용시 주의사항.
- 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다.
- 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있다.
- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.

### 객체기반 프로그래밍 Object-Based Programming.
- 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식.
- 클래스 없이 오직 객체만을 사용하는 프로그래밍 방식.
- Visual Basic.

### 객체지향 프로그래밍 Object-Oriented Programming.
- 객체들을 조합해서 애플리케이션을 개발하지만 상속과 다형성을 지원한다.
- 객체지향 프로그래밍도 객체기반 프로그래밍에 한 종류이다.
- C++, 자바, 루비, C# 등.

### 개념 관점의 타입.
- 우리가 인식하는 객체들에 적용하는 개념이나 아이디어.
- 타입은 사물을 분류하기 위한 틀로 사용된다.
- 어떤 대상이 타입으로 분류될 때 그 대상을 타입의 인스턴스 또는 객체라고 부른다. 

### 타입의 구성요소.
- 심볼 symbol : 타입에 이름을 붙인 것.
- 내연 intension : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
- 외면 extension : 타입에 속하는 객체들의 집합이다.

### 프로그래밍 언어 관점의 타입.
- 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다.
- 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 의미한다.

### 프로그래밍 언어 관점의 타입에 두 가지 목적.
1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
   - 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아 준다.
2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
   - 타입에 따라 같은 오퍼레이션이라도 다른 문맥을 제공한다.
> 정리하면, 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지한다.

### 객체지향 패러다임 관점의 타입.
- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다.
- 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
- 객체에게 중요한 것은 속성이 아니라 행동이다. (동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 다른 타입이다)

--------------------------------------------------------------------------------------------------------------

> ## 타입 계층.

### 용어 정리.
- 객체 = 인스턴스.
- 클래스 = 클래스.

### 슈퍼타입 supertype.
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입.
- 외연은 더 크고, 내연은 더 일반적이다.

### 서브타입 subtype.
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 특수한(구체적인) 타입.
- 외연은 더 작고, 내연은 더 특수(구체적)하다.

### 내연 관점에서 일반화와 특수화.
- 일반화.
  - 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정.
- 특수화.
  - 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정.
  - 일반적인 타입의 정의를 좀 더 구체화한 것.

### 외연 관점에서 일반적인 타입, 특수한 타입.
- 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋(superset)이다.
- 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋(subset)이다.
- 특수한 타입에 속한 인스턴스는 일반적인 타입의 인스턴스이기도 하다.

### 일반화.
- 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

### 특수화.
- 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

### 슈퍼타입.
- 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것.

### 서브타입.
- 집합에 포함되는 인스턴들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 좀 더 구체적이다.
- 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것.
- 서브타입의 인스턴스는 슈퍼 타입의 인스턴스로 간주될 수 있다.

### 퍼블릭 인터페이스.
- 객체의 타입을 결정한다.
- 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이다.
- 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이다.

--------------------------------------------------------------------------------------------------------------

> ## 서브클래싱과 서브타이핑.

### 마틴 오더스키의 상속을 사용해야 되는 경우.
1. 상속 관계가 is-a 관계를 모델링하는가 ?
   - 어플리케이션을 구성하는 어휘에 대한 우리의 관점에 기반한다.
   - 일반적으로 "자식 클래스"는 "부모 클래스"다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
   - 때때로 is-a 관계로 표현할 수 있더라도 상속을 사용해서는 안되는 경우도 있다.
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가 ?
   - 상속 계층을 사용하는 클라이언트 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다.
   - 이러한 특징을 자식 클래스와 부모 클래스 사이의 행동 호환성이라고 부른다.
   - 설계 관점에서 상속을 적용할지 여부를 결정하기 위해 2번째 질문에 초점을 맞추는 것이 중요하다.

### is-a 관계.
- 현실세계에서 객체지향세계로 클래스를 추상화해오는 과정에서 상황에 따라 is-a관계는 되지만, 행동 호환성이 안되는 경우가 발생한다.
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다. (새 -> 펭귄 예시)
- 따라서 슈퍼타입과 서브타입 관계에서는 is-a 보다 행동 호환성이 더 중요하다.

### 행동 호환성.
- 행동 호환 여부는 클라이언트의 관점에서 판단된다.
- 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.

### 펭귄 문제 해결 방안 및 문제점.
1. 펭귄 fly()에 내부 구현을 비워두기.
   - 클라이언트 입장에서 원하는 행동을 하지 않는다.
2. 펭귄 fly()에 내부 구현에 Exception을 발생하도록 만들기.
   - 클라이언트 입장에서 원하는 행동을 하지 않는다.
3. 클라이언트 fly() 호출 메서드에서 if 조건문으로 펭귄일 경우 호출하지 않기.
   - 날지 못하는 새가 추가될 때마다 코드를 수정해줘야 한다.

### 클라이언트의 기대에 따라 계층 분리.
1. 날 수 있는 새라는 FlyingBird 클래스를 따로 지정한다.
2. 인터페이스를 통해 Flyer, Walker 등 행동에 따라 분리한다.
   - 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.

### 재사용 주의사항.
- 재사용을 위해서 상속을 사용하지 말고, 합성을 사용해라.
- 재사용하려는 클래스의 퍼블릭 인터페이스를 확인하고 퍼블릭 인터페이스를 통해 재사용이 어려운 경우 코드를 수정해야 한다.

### 인터페이스 분리 원칙 Interface Segregation Principle ISP.
- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙.
- 이 원칙은 비대한 인터페이스의 단점을 해결한다.
- 비대한 인터페이스는 응집성이 없는 인터페이스를 가지는 클래스다.

### 설계와 이상.
- 모든 소프트웨어에 이상적인 설계 같은 것은 없다.
- 최고의 설계는 제작하려는 소프트웨어 시스템이 기대하는 바에 따라 달라진다.
- 확장을 대비해서 코드를 작성하면 코드가 복잡해지고, 확장을 대비하지 않으면 유지/보수 시에 어려움을 겪는다.

### 상속을 사용하는 두 가지 목적.
1. 서브클래싱 subclassing.
   - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우.
   - 자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
   - 서브 클래싱을 구현 상속 또는 클래스 상속이라고 부르기도 한다.
2. 서브타이핑 subtyping.
   - 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다.
   - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
   - 부모 클래스는 슈퍼 타입이 되고, 자식 크래스는 서브타입이 된다.
   - 서브타이핑을 인터페이스 상속이라고 부르기도 한다.
   - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.
   - 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야 한다. (대체 가능성)

--------------------------------------------------------------------------------------------------------------

> ## 리스코프 치환 원칙. 

### 리스코프 치환 원칙 Liskov Substitution Principle LSP.
- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 자식 클래스와 부모 클래스가 행동 호환성을 가져야 한다.
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 갖어을 준수해야 한다.

### 클라이언트와 대체 가능성.
- 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바르다.
- 행동 호환성과 리스코프 치환 원칙에서 가장 중요한 점은 대체 가능성을 결정하는 것은 클라이언트다.

### is-a 관계 다시 살펴보기.
- 클라이언트를 배제한 is-a 관계는 혼란으로 몰아갈 가능성이 높다.
- 행동을 고려하지 않은 두 타입의 이름이 단순히 is-a로 연결 가능하다고 해서 상속 관계로 연결하지 마라.

### 리스코프 치환 원칙은 유연한 설계의 기반이다.
- 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.
- 새로운 자식 클래스를 추가해도 클라이언트 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 확장할 수 있다.

### 의존성 역전 원칙.
- 수정할 가능성이 적은 모듈에 의존하는 원칙.

### 개방-폐쇄 원칙.
- 기능 확장을 하면서 기존 코드를 수정할 필요 없는 것.
- 클라이언트 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.

### 타입 계층과 리스코프 치환 원칙.
- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이다.
- 자바에서는 인터페이스를 통해 클래스 사이의 상속을 하지 않고 서브타이핑 관계를 구현할 수 있다.

--------------------------------------------------------------------------------------------------------------

> ## 계약에 의한 설계와 서브타이핑.

### 계약에 의한 설계 Design By Contract DBC.
- 클라이언트와 서버 사이의 협력을 의무(obligation)와 이익(benefit)으로 구성된 계약의 관점에서 표현하는 것.

### 계약의 의한 설계 구성요소.
1. 사전조건 precondition. 
   - 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 것.
2. 사후조건 postcondition.
   - 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 것.
3. 클래스 불변식 class invariant.
   - 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 것.

### 리스코프 치환 원칙과 계약에 의한 설계 사이의 관계.
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.

### 계약 관점에서 상속의 특징.
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 수 있다.
- 자식 클래스에서 부모 클래스의 메서드보다 더 강력한 제약조건을 걸면 문제가 발생한다.

### 사전 조건.
- 서브타입에 더 강력한 사전조건을 정의할 수 없다.
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다. 

### 사후조건.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.



























