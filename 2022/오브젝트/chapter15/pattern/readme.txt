
# 디자인 패턴과 프레임워크.

--------------------------------------------------------------------------------------------------------------

> ## 용어 정리. 

### 디자인 패턴.
- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법.

### 디자인 패턴의 목적.
- 설계를 재사용하는 것.
- 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음.

### 프레임워크.
- 설계와 코드를 함께 재사용하기 위한 것.
- 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.

--------------------------------------------------------------------------------------------------------------

> ## 디자인 패턴과 설계 재사용.

### 패턴이란 ?
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

### 마틴 파울러의 디자인 패턴.
- 디자인 패턴은 하나의 실무 컨텍스트에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어.
- 아이디어라는 용어를 사용한 이유는 어떤 것도 패턴이 될 수 있기 때문이다.

### 패턴의 특징.
- 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다.

### 패턴 언어 Pattern Language.
- 연관된 패턴들의 집합들의 모임.
- 연관된 패턴 카테고리뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 규칙을 포함한다.
- 패턴 시스템과 거의 동일한 의미로 사용되고 있다.

### 패턴 분류.
- 패턴의 범위나 적용 단계에 따라 분류한다.
  1. 아키텍처 패턴 Architecture Pattern.
  2. 분석 패턴 Analysis Pattern.
  3. Design Pattern.
  4. 이디어 Idiom.

### 아키텍처 패턴.
- 디자인 패턴 상위에 존재하며, 소프트웨어의 전체적인 구조를 결정하기 위해 사용한다.
- 미리 정의된 서브시스템들을 제공하고, 각 서브시스템의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
- 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 디자인 패턴과 마찬가지로 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.

### 디자인 패턴.
- 특정 정황 내에서 일반적인 설계 문제를 해결.
- 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.

### 이디엄.
- 디자인 패턴의 하위에 존재한다.
- 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.
- 주어진 언어의 기능을 사용해 컴포넌트 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
- 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.

### 분석 패턴.
- 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
- 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
- 단 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.

### 패턴과 책임-주도 설계.
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
- 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
- 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

### 캡슐화와 디자인 패턴.
- 몇 가지 이례적인 경우를 제외하면 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.
- 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
- 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다.

### 전략패턴과 템플릿 메서드 패턴.
- 전략 패턴은 합성을 사용하고, 템플릿 메서드 패턴은 상속을 사용한다.
- 전략 패턴은 인터페이스를 사용하고, 템플릿 메서드 패턴은 인터페이스 또는 추상 클래스를 사용한다.

### 패턴 만능주의.
- 패턴을 익힌 후 모든 코드를 패턴으로 해결하려는 것을 말한다.
- 패턴을 맹목적으로 믿지 말고 현재 상황에 패턴이 맞지 않다면 수정해서 사용해야 한다.
- 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
- 설계를 좀 더 단순하고 명확하게 만들 수 있는 방법이 없는지 고민하고 적용해라.

### 패턴 주의사항.
- 패턴을 알지 못하는 사람들은 복잡한 구조로 인해 코드를 쉽게 이해할 수 없게 된다.
- 패턴을 적용할 떄는 함께 작업하는 사람들이 패턴에 익숙한지 여부를 확인해야 한다.

--------------------------------------------------------------------------------------------------------------

> ## 프레임워크와 코드 재사용.

### 소프트웨어 다양성.
- 애플리케이션과 도메인의 다양성으로 인해 여러 문제들이 아주 비슷한 경우는 거의 없다고 한다.
- 따라서 가장 기본이 되는 아주 적은 부분만이 일반화될 수 있다. (재사용을 많이 할 수 없다)

### 프레임워크.
- 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계.
- 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격을 의미한다. (프레임워크의 사용 목적)
- 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들 간의 상호작용, 객체와 클래스 조합 방법, 제어 흐름에 대해 정의한다.
- 설계의 가변성을 미리 정의해 뒀기 때문에 애플리케이션 설계자나 구현자는 종속된 부분에 대해서만 설계하면 된다.
- 프레임워크는 코드의 재사용보다는 설계 자체의 재사용을 중요시한다.

### 상위 정책과 하위 정책으로 패키지 분리하기.
- 의존성 역전 원칙에 맞게 상위 정책과 세부 사항 모두 추상화에 의존하게 만들어야 한다. 
- 변하지 않는 것은 상위 정책에 작성하고, 변하는 것은 세부 사항에 작성한다. (배포 단위로 분리)
- 상위 정책과 하위정책을 완전히 분리하면 상위 정책 패키지를 여러 어플리케이션에서 재사용할 수 있는 기반이 마련된다.

### 제어 역전 원리 의미.
- 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
- 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다.
- '할리우드 Hollywood 원리' 라고도 불린다.

### 제어 역전 원리 특징.
- 상위 정책을 재사용한다는 것은 핵심 개념들 사이의 협력 관계를 재사용한다는 것을 의미한다.
- 의존성 역전 원리를 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.
- 의존성 역전이 없다면 절차형 코드이고, 의존성 역전이 되어있다면 객체지향 설계이다.

### 훅 hook.
- 완성되지 않은 채로 남겨진 동작을 의미한다.
- 프레임워크처럼 상위 정책 패키지를 통해 협력 부분을 정의하고, 세부 사항을 비워놓은 상태를 의미한다.
- 훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다.

### 라이브러리.
- 라이브러리를 사용해서 애플리케이션을 작성하면 애플리케이션이 필요한 라이브러리의 코드를 호출한다.
- 애플리케이션 자체가 언제 라이브러리를 사용할 것인지를 스스로 제어한다.

### 제어 역전 정리.
- 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘.









