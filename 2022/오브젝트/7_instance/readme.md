# 객체 분해.

-------------------------------------------------------------------------------------------------

> ## 프로시저 추상화와 데이터 추상화.

### 인지 과부하 cognitive overload.
- 문제 해결에 필요한 요소의 수가 너무 많아졌을 때 문제 해결 능력이 급격히 떨어지는 현상.

### 추상화.
- 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업.

### 분해 decomposition.
- 큰 문제를 해결 가능한 작은 문제로 나누는 작업.

### 프로그래밍 패러다임.
- 프로그래밍 패러다임은 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합이다. 
- 프로그래밍 패러다임은 프로그래밍을 구성하기 위해 사용하는 추상화의 종류와 이 추상화를 통해 소프트웨어를 분해하는 방법<br>
  2가지 요소로 결정된다.
- 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.

### 추상화 메커니즘.
1. 프로시저 추상화 procedure abstraction.
   - 소프트웨어가 무엇을 해야 하는지를 추상화한다.
2. 데이터 추상화 data abstraction.
   - 소프트웨어가 무엇을 알아야 하는지를 추상화한다.

### 시스템 분해 방법.
- 시스템 분해 방법을 결정하려면 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지를 결정해야 한다.
- 프로시저 추상화를 중심으로 시스템을 분해하는 방법.
  - 기능 분해 functional decomposition 또는 알고리즘 분해 algorithmic decomposition 라고 부른다.
- 데이터 추상화를 중심으로 시스템을 분해하는 방법.
  1. 타입을 추상화 type abstraction.
     - 추상 데이터 타입 Abstract Data Type 이라고 부른다.
  2. 데이터를 중심으로 프로시저를 추상화 procedure abstraction.
     - 객체지향 Object-Oriented 라고 부른다.

### 객체 지향.
- 프로그래밍 언어의 관점에서 객체지향이란 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것.

-------------------------------------------------------------------------------------------------

> ## 프로시저 추상화와 기능 분해.

### 기능 분해.
- 기능 분해의 관점에서 추상화의 단위는 프로시저이며 시스템은 프로시저를 단위로 분해된다.
- 프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 모아놓음으로써 로직은 재사용하고 중복을 방지하는 추상화 방법.
- 프로시저를 추상화라고 부르는 이유는 내부의 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다.
  - 프로시저는 잠재적으로 정보은닉의 가능성을 제시.
  - 프로시저만으로 효과적인 정보은닉 체계를 구축할 수 없다.

### 하향식 접근법 Top-Down Approach.
- 시스템을 구성하는 가장 최상위 기능을 정의하고, 최상위 기능을 좀 더 작은 단계의 기능으로 분해해 나가는 방법.
- 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.
- 하위 기능은 자신의 바로 상위 기능보다 더 구체적이어야 한다.
- 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다.

### 하향식 기능 분해의 문제점.
- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
- 너무 이른 시기에 함수들의 싫애 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.

### 하나의 메인함수라는 비현실적인 아이디어.
- 대부분의 경우 추가되는 기능은 최초에 배포된 메인 함수의 일부가 아닐 것이다.
- 중요하게 생각됐던 메인 함수는 기능이 추가됨에 따라 여러 함수들 중 하나가 될 것이다.
- 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다.

### 메인 함수의 빈번한 재설계.
- 시스템 안에서 여러 개의 최상위 함수가 존재하기 때문에 하향식 기능 분해는 새로운 기능을 추가할 때마다 메인 함수를 수정해야 한다.
- 기존 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다.

### 비즈니스 로직과 사용자 인터페이스의 결합.
- 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식을 고민하도록 강요한다.
- 결과적으로 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
- 문제점은 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다는 것이다.
  - 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분이다.
  - 비즈니스 로직은 사용자 인터페이스에 비해 변경이 적게 발생한다.

### 성급하게 결정된 실행 순서.
- 하향식 접근법은 처음부터 구현을 염두에 두기 때문에 자연스럽게 함수들의 실행 순서를 정의하는 시간 제약을 강조한다.
- 실행 순서나 조건, 반복과 같은 제어 구조를 미리 결정해야 하기 때문에 중앙집중 제어 스타일의 형태를 띨 수밖에 없다.
- 문제는 중요한 설계 결정사항인 함수의 제어 구조가 빈번한 변경의 대상이라는 점이다.
- 기능이 추가되거나 변경될 때마다 초기에 결정된 함수들의 제어 구조가 올바르지 않다는 것이 판명된다.
- 이러한 문제를 해결할 수 있는 한 가지 방법은 시간적인 제약이 아니라 논리적 제약을 설계의 기준으로 삼는 것이다.

### 재사용.
- 재사용은 일반성의 의미를 포함한다.
- 함수가 재사용 가능하려면 상위 함수보다 더 일반적이어야 한다.

### 데이터 변경으로 인한 파급효과.
- 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.
- 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확하게 분리해야 한다.

### 언제 하향식 분해가 유용한가 ?
- 설계가 어느 정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기 용이하다.
- 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다.
- 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.
- 하향식 분해는 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임으로 남아 있다.

-------------------------------------------------------------------------------------------------

> ## 모듈.

### 정보 은닉 information hiding.
- 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 덜 변경되는 안정적인 인터페이스 뒤로 감추는 것.
- 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.

### 모듈 분해.
- 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.
- 비밀을 결정하고 모듈을 분해한 후에는 기능 분해를 이용해 모듈에 필요한 퍼블릭 인텊페이스를 구현할 수 있다.

### 모듈이 감춰야 하는 비밀.
1. 복잡성.
   - 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다.
   - 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
2. 변경 가능성.
   - 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 떄 파급효과가 커진다.
   - 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 인터페이스를 제공한다.

### 모듈의 장점.
1. 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
   - 모듈을 사용하면 모듈 내부에 정의된 변수를 직접 참조하는 코드의 위치를 모듈 내부로 제한할 수 있다.
   - 어떤 데이터가 변경됐을 때 영향을 받는 함수를 찾기 위해 해당 데이터를 정의한 모듈만 검색하면 된다.
   - 모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기가 더 용이하다.
2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
   - 사용자 입력과 화면 출력을 Employees 모듈이 아닌 외부에 뒀다.
   - Employees 모듈은 비즈니스 로직과 관련된 관심사만을 담당하며 사용자 인터페이스와 관련된 관심사는 main 함수에 있다.
3. 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
   - 모듈의 한 가지 용도는 네임스페이스를 제공하는 것이다.
   - 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있게 된다.
   - 모듈은 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.

### 모듈 특징.
- 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
- 각 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다. (높은 결합도)
- 모듈과 모듈 사이에는 퍼블릭 인터페이스를 통해서만 통신해야 한다. (낮은 결합도)
- 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위다.

### 모듈의 단점.
- 인스턴스의 개념을 제공하지 않는다는 점이다.
- 다수의 직원 인스턴스가 존재하는 추상화 메커니즘이 필요하다.
- 이를 만족시키기 위해 등장한 개념이 바로 추상 데이터 타입이다.

-------------------------------------------------------------------------------------------------

> ## 데이터 추상화와 추상 데이터 타입.

### 타입 Type.
- 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.
- 프로그래밍 언어는 다양한 형태의 내장 타입 built-in type 을 제공한다.

### 추상 데이터 타입 구현에 필요한 것.
1. 타입 정의를 선언할 수 있어야 한다.
2. 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
3. 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
4. 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

### 추상 데이터 타입.
- 추상 데이터 타입은 시스템의 상태를 저장할 데이터를 표현한다.
- 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다.
- 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것이다.

-------------------------------------------------------------------------------------------------

> ## 클래스.

### 클래스와 추상 데이터 타입.
- 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.
- 가장 핵심적인 차이는 클래스는 상속과 다형성을 지원하는 데 추상 데이터 타입은 지원하지 못한다.
- 클래스는 객체 지향 프로그래밍, 추상 데이터 타입은 객체 기반 프로그래밍이라고 부르기도 한다.

### 윌리엄 쿡의 클래스와 추상 데이터 타입.
- 추상 데이터 타입은 타입을 추상화한 것. (type abstraction)
- 클래스는 절차를 추상화한 것이다. (procedural abstraction)

### 다형성.
- 클래스를 이용한 다형성은 절차에 대한 차이점을 감춘다.
- 다시 말해 객체지향은 절차 추상화이다.
- 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 추상화한다.

### 클래스와 추상 데이터 타입 구분 방법.
- 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주.
- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.
- 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.
- 흔히 객체지향이란 조건문을 제거하는 것이라는 편협한 견해가 널리 퍼진 이유가 바로 이 때문이다.

### 개방 폐쇄 원칙 OCP Open-Closed Priciple.
- 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성.

### 설계의 유용성.
- 설계는 변경과 관련된 것이다.
- 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.
- 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경이 타입추가에 관한 것인지 오퍼레이션 추가에 관한 것인지에<br> 
  따라 달라진다.
- 타입 추가에 관한 것이 더 큰 경우 객체지향을 사용한다.
- 추상 데이터 타입의 경우 타입을 추가하려면 클라이언트 코드를 수정해야 한다.
- 오퍼레이션 추가에 관한 것이 더 큰 경우 추상 데이터 타입을 사용한다.
- 객체지향의 경우 새로운 오퍼레이션을 추가하기 위해서는 상속 계층에 속하는 모든 클래스를 한번에 수정해야 한다.


### 데이터 주도 설계.
- 추상 데이터 타입의 접근법을 객체지향 설계에 구현한 것.
- 책임 주도 설계는 데이터 주도 설계 방법을 개선하고자 하는 노력의 산물이다.
- 티모시 버드의 정리.
  - 추상 데이터 타입이 데이터 중심적인 관점을 취한다.
  - 객체지향은 서비스 중심적인 관점을 취한다.

### 정리.
- 객체가 참여할 협력을 결정하고 협력에 필요한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라.
- 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층 안에 각 절차를 추상화하라.
- 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되어서는<br>
  안 된다.
















