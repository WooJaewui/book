
 리팩터링 원칙(2)



 # 언제 리팩터링해야 할까?

돈 로버츠의 3의 법칙.
처음에는 그냥 한다.
비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
비슷한 일을 세 번째 하게 되면 리팩터링한다.

기능을 쉽게 추가하게 만들기.
리팩터링 하기 가장 좋은 시점은 기능을 새로 추가하기 직전이다.
구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

코드를 이해하기 쉽게 만들기.
코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

쓰레기 줍기 리팩터링.
로직이 쓸데없이 복잡하거나, 
매개변수화한 함수 하나면 될 일을 여러 함수로 작성해놨던 일들을 정리한다.
간단한 수정은 즉시 고치고, 시간이 걸리는 일은 짧은 메모만 남기고 나중에 처리한다.

계획된 리팩터링과 수시로 하는 리팩터링.
보기 싫은 코드를 발견하면 리팩터링하자.
잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
계획된 리팩터링은 최소한으로 줄이고, 기회가 될 때마다 리팩터링 해야 한다.

오래 걸리는 리팩터링.
라이브러리를 교체할 때는 기존 것과 새것 모두를 포용하는 추상 인터페이스를 마련하자.

코드 리뷰에 리팩터링 활용하기.
내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다.
다른 사람의 아이디어를 얻을 수 있다.
코드 작성자가 참석해야 코드 작성의 맥락을 정확히 이해할 수 있다.

관리자에게 뭐라고 말해야 할까?
기술을 모르는 관리자에게는 리팩터링한다고 말하지 말라.



 # 리팩터링하지 말아야 될 때.

리팩터링하지 말아야 될 때.
내부 동작을 정확히 이해하지 못했거나, 이해해야 할 시점이 아직 안온 경우.
리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때.



 # 리팩터링 시 고려할 문제.

새 기능 개발 속도 저하.
리팩터링의 궁극적인 목적은 개발 속도를 높여, 적은 노력으로 많은 가치를 창출하는 것.
새 기능을 구현해넣기 편해지겠다 싶은 리팩터링은 바로 진행한다.
직접 건드릴 일이 거의 없거나, 불편한 정도가 심하지 않으면 리팩터링 하지 않는다.

코드 소유권.
함수를 호출하는 코드의 소유자가 다른 사람이라면 쉽게 변경할 수 없다.
이러한 경우에는 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정.
소유권을 너무 잘게 쪼개서 나누지 않는 것이 좋다.

일반적인 팀 작업 방식.
버전 관리 시스템을 사용하여 팀원마다 브랜치를 하나씩 맡아서 작업하다가,
결과물이 어느 정도 쌓이면 마스터 브랜치에 통합해서 팀원과 공유하는 것이다.

브랜치.
프로덕션 버전으로 릴리스할 때가 돼서야 마스터에 통합하는 경우도 있다.
독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기 어려워진다.

테스팅.
리팩터링하다가 실수를 저질렀을 때 가장 핵심은 오류를 재빨리 잡는 데 있다.
리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다.

레거시 코드.
레거시 코드를 리팩터링할 때 테스트를 중점적으로 생각하자.



 # 리팩터링, 아키텍처, 애그니.

유연성 메커니즘 flexibility mechanism.
향후 변경에 유연하게 대처할 수 있는 방식을 소프트웨어에 심어두는 것.

YAGNI You aren't going to need it.
설계, 아키텍처를 최소한으로 고려하고 코드 작업을 실행하는 것을 의미한다.
비슷한 말로 simple design, incremental design이 있다.



 # 리팩터링과 소프트웨어 개발 프로세스.

테스트 주도 개발 TDD Test-Driven Development.
자가 테스트 코드와 리팩터링을 합친말이다.

agile thinking.
아무런 계획이 없는 개발 방법과 계획이 지나치게 많은 개발 방법들 사이에서 타협점을 찾고자 하는 방법론.

리팩터링의 시너지 효과.
자가 테스트 코드, 지속적 통합, 리팩터링.



 # 리팩터링과 성능.

고민거리.
직관적인 설계 vs 성능.

빠른 소프트웨어를 작성하는 3가지 방법.
시간 예산 분배 Time budgeting 방식 - 컴포넌트마다 자원 예산을 할당한다.
섣불리 추측하지 말고 성능을 측정해보자.
성능 최적화에 돌입하기 전까지는 코드를 다루기 쉽게 만드는데 집중한다.

리팩터링이 최적화에 도움이 되는 점.
성능 튜닝에 시간을 벌 수 있다 ( 기능 추가 시간을 단축 )
성능을 더 세밀하게 분석할 수 있다.




