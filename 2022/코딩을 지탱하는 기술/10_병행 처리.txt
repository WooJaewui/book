
 병행 처리.
 172 ~ 185page.



 # 잘게 분할해서 실행한다.

병행처리란 ?
여러가지 일을 동시에 처리할 수 있는 기술이다.
편리한 병행 처리를 실현하기 위해 프로세스나 쓰레드 등의 개념이 만들어졌다.

잘게 분할해서 실행한다.
프로세서가 하나인 경우에 병행처리는 짧은 순간에 여러가지 일을 변경해가면서 실행.
사실 하나의 처리만 실행되지만, 사람 눈에는 복수의 처리가 병행해서 동작하고 있는 듯 보인다.



 # 처리를 변경하는 2가지 방법.

협력적 멀티태스크.
타이밍이 좋은 시점에서 교대하는 방법이다.
어떠한 처리가 '교대해도 좋아' 라고 말하지 않고 계속 실행하면 다른 처리는 계속 기다려야한다.

선점적 멀티태스크.
일정 시간에 교대하는 방법이다.
태스크 스케쥴러가 존재하고, 일정 시간마다 처리를 교대해준다.



 # 경합 상태 방지법.

경합 상태( Race condition )의 3가지 조건.
2가지 처리가 변수를 공유하고 있다.
적어도 하나의 처리가 그 변수를 변경한다.
한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성이 있다.
3가지 조건 중 하나라도 제거할 수 있다면 병행 실행 시 안정된 프로그램을 만들 수 있다.

공유하지 않는다.
메모리를 공유하지 않는다는 방법은 여러과정을 거치면서 문제점이 발견되 거의 사용되지 않는다.

액터 모델.
1973년에 발표된 병행 처리를 표현하기 위한 모델.

변경하지 않는다.
일부 변수를 변경할 수 없게 한다.
C++ - const, Scala - val, Java - Immutable.

끼어들지 않는다.
협력적 쓰레드의 사용.
끼어들면 곤란해지는 처리에 표식을 붙인다 - 끼어들면 안되는 부분을 설정한다.
Java - synchronized 블록



 # 락의 문제점과 해결책.

락의 문제점.
교착 상태가 발생 - a가 b를 실행해야되고, b가 a가 실행해야되는 상황에서 서로 락이 걸리는 경우.
합성할 수 없다 - 락을 걸면 한 번에 묶어서 처리해야되는 로직들을 처리하기 힘들 수 있다.

트랜잭션 메모리.
일시적으로 별도 버전을 만들어서 어떠한 로직을 수행하고 모든 처리가 끝나면 결과값에 반영한다.
단, 쓰는 처리의 빈도가 높을 떄는 다시 고쳐서 하기 작업이 다발해서 성능이 나빠진다.

트랜잭션 메모리의 역사 - 하드웨어로 구현.
1986년 Symbolics라는 회사가 트랜잭션을 하드웨어로 구현하려는 아이디를 제안.
상업적으로 실패했다.

트랜잭션 메모리의 역사 - 소프트웨로 구현.
1995년에 소프트웨어로 트랜잭션 메모리를 구현하려는 논문이 발표.
2005년에 Microsoft가 Concurrent Haskell을 사용해서 트랜잭션 메모리를 실현하는 논문을 발표.

트랜잭션 메모리는 성공할까 ?
2010년 Microsoft는 .NET Framework에 소프트웨어 트랜잭션 메모리를 내장하는 것을 중지했다.
2013년 Intel의 새로운 CPU에 트랜잭션 메모리의 일부 기능이 탑재될 예정.

정리.
공유 -> 비공유 -> 공유, 협력 -> 비협력 -> 협력, 하드웨어 -> 소프트웨어 -> 하드웨어.
2가지 방법 모두 명확히 알고 활용할 수 있어야된다.




