
 제네릭 - 677page.


 # 제네릭에 강점.

1. 컴파일시 강한 타입 체크를 할 수 있다.
 - 잘못된 타입 때문에 발생하는 문제점을 제거할 수 있다.

2. 타입 변환을 제거한다.
 - 불필요한 타입 변환은 프로그램 성능을 저하시키는데, 제네릭은 이러한 타입 변환을 줄여준다.



 # 제네릭 타입.

제네릭 타입 : 여러 개의 타입이 들어갈 수 있는 변수에 상황에 따라 제네릭 타입변수를 통해 타입을 제어한다.
타입변수 : 변수 안에 값이 아닌 타입을 담아서 어떤 타입인지 정해줄때 사용한다.

설명.
Class안에서 제네릭 타입을 코딩을 해 놓으면 객체 생성시 <Type>으로 제한된 Type만 사용하게 할 수 있다.
Class안에서 <T>는 Type을 의미하며, 변수 이름과 같아서 아무거나 바꿔도 상관없다.



 # 멀티 파라미터.

설명.
제네릭 타입은 멀티 타입 파라미터를 사용할 수 있는데, 각 타입을 콤마로 구분한다.

사용.
public class ClassName<T, M> { 
	private T t_var; 
	private M m_var; 
	....
}

주의사항.
T와 M에 사용되는 멤버들을 잘 구분해서 사용해야 된다.
객체를 생성하는 부분은 < > 안에 타입명을 쓰지 않아도 알아서 유추해서 채워준다.



 # 제네릭 메소드.

설명.
메소드를 타입 변수를 통해 type을 제어할 수 있다.

사용.
public <T> ReturnType<T> methodName( var ) { 실행할 문장; }
Class.<T>methodName( var ); 

주의사항.
Class.<T>methodName( var )를 사용시 <T>는 거의 생략가능하다. ( 앞이나 뒤에 표현이 되어있다 )
static 메소드에는 클래스에 선언된 타입변수를 쓸 수 없다. ( 메소드에서 타입변수를 선언해서 사용 )



 # 제한된 타입 파라미터.

설명.
타입 변수를 제한해야 하는 경우에 사용한다. ( 숫자만 와야 되는 경우 등 )

사용.
< T extends 부모타입 >

주의사항.
부모타입에는 클래스뿐만 아니라 인터페이스도 사용할 수 있다.
부모타입와 부모타입의 자식타입들이 타입변수에 사용될 수 있다.



 # 와일드 카드 wildcard <?>.

<?> : 모든 type.
<? extends 부모타입 > : 부모타입 + 자식타입.
<? super 자식타입 > : 자식타입 + 부모타입.



 # 제네릭을 가진 클래스, 인터페이스 상속과 구현.

제네릭을 가진 클래스,인터페이스를 상속받으면 자식클래스는 부모 제네릭 이상으로 가져야한다.
( 줄일 수 없다 )




 






























