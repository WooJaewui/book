
# 리팩터링, 테스팅, 디버깅.

-------------------------------------------------------------------------------------------------------------------------------

> ## 가독성과 유연성을 개선하는 리팩터링.

### 코드 가독성.
- '어떤 코드를 다른 사람도 쉽게 이해할 수 있음'을 의미한다.

### 람다, 메서드 참조, 스트림을 활용한 코드 가독성 개선 방법.
- 익명 클래스를 람다 표현식으로 리팩터링하기.
- 람다 표현식을 메서드 참조로 리팩터링하기.
- 명령형 데이터 처리를 스트림으로 리팩터링하기.

### 익명 클래스 람다 표현식 변환 주의사항.
1. 익명 클래스에서 사용한 this, super는 람다 표현식에서 다른 의미를 갖는다.
   - 익명 클래스에서 this는 익명 클래스 자신을 가리킨다.
   - 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
2. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다 (shadow variable)
   - 람다 표현식으로는 가릴 수 없다. (컴파일 에러 발생)
3. 익명 클래스를 람다 표현식으로 바꾸면 컨텍스트 오버로딩에 따른 모호함이 초래될 수 있다.
   - 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해진다.
   - 람다의 형식은 컨텍스트에 따라 달라진다.
   - 오버로딩된 메서드인 경우 두 메서드의 인자에 대해 모호함이 발생할 수 있다. (명시적 형변환으로 해결 가능)

### 람다 표현식을 메서드 참조로 리팩터링하기.
- 람다 표현식 대신 메서드 참조를 이용하면 가독성을 높일 수 있다. (코드 -> 메서드 호출)
- 메서드 참조의 메서드명으로 코드의 의도를 명확하게 알릴 수 있기 때문이다.
- 내장 컬렉털르 이용함녀 코드 자체로 문제를 더 명확하게 설명할 수 있다.

### 명령형 데이터 처리를 스트림으로 리팩터링하기.
- 스트림은 쇼트서킷, 게으름이라는 강력한 최적화와 멀티코어 아키텍처를 활용할 수 있는 지름길을 제공한다.
- 반면 명령형 코드는 전체 구현을 자세히 살펴봐야 전체 코드의 의도를 이해할 수 있고, 병렬로 실행시키기도 매우 어렵다.

### 코드 유연성 개선.
- 함수형 인터페이스 적용.
   - 람다 표현식을 사용하기 위한 함수형 인터페이스가 필요하다.
   - 조건부 연기 실행 conditional deferred execution, 실행 어라운드 execute around 패턴을 통해 람다 표현식 리팩터링을 살펴보자.

### 조건부 연기 실행 conditional deferred execution.
- 클라이언트 코드에서 객체 상태를 자주 확인하는 상황, 객체의 일부 메서드를 호출하는 상황인 경우에 
  내부적으로 객체의 상태를 확인한 다음에 메서드를 호출하도록 새로운 메서드를 구현하는 것이 좋다.
- 코드 가독성도 좋아지고, 캡슐화도 강화된다.

### 실행 어라운드.
- 같은 준비, 종료 과정을 반복적으로 수행하는 코드가 있다면 이를 람다로 변환할 수 있다. (준비, 종료 과정 처리 로직을 재사용)

-------------------------------------------------------------------------------------------------------------------------------

> ## 람다로 객체지향 디자인 패턴 리팩터링하기.

### 디자인 패턴.
- 공통적인 소프트웨어 문제를 설계할 때 재사용할 수 있는, 검증된 청사진을 제공한다.
- 람다를 이용하면 이전에 디자인 패턴으로 해결하던 문제를 더 쉽고 간단하게 핻결할 수 있다.
- 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리 메서드에 대해 알아본다.

### 전략 패턴.
- 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다.
- 전략 패턴은 3부분으로 나뉘어 진다.
  - 알고리즘을 나타내는 인터페이스.
  - 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현 클래스.
  - 전략 객체를 사용하는 한 개 이상의 클라이언트.

### 람다식 + 전략패턴.
- 람다 표현식을 이용하면 전략 디자인 패턴에서 발생하는 자잘한 코드를 제거할 수 있다.
- 람다 표현식은 코드 조각(전략)을 캡슈로하한다.
- 람다 표현식으로 전략 디자인 패턴을 대신할 수 있다.

### 템플릿 메서드 패턴.
- 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 템플리세 메서드 디자인 패턴을 사용한다.

### 람다 + 템플릿 메서드.
- 람다 표현식으로 자잘한 코드를 제거할 수 있따.

### 옵저버 패턴.
- 어떤 이벤트가 발생했을 때 한 객체(주체)가 다른 객체 리스트(옵저버)에 자동으로 알림을 보내야 하는 상황에서 사용한다.
- GUI 어플리케이션에서 자주 등장한다.
    - 주체.
    - 옵저버.
    - 옵저버 구현체.

### 람다 + 옵저버 패턴.
- 옵버저 구현 클래스를 명시적으로 인스턴스화하지 않고 람다 표현식으로 직접 전달해서 실행할 동작을 지정할 수 있다.
- 항상 람다 표현식을 사용하는 것이 좋은 것은 아니다.
  - 옵저버가 상태를 가지며, 여러 메서드를 정의하는 등 복잡하다면 클래스 구현방식이 더 좋을 수 있다.

### 의무 체인.
- 작업 처리 객체의 체인(동작 체인 등)을 만들 때는 의무 체인 패턴을 사용한다.
- 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는 식이다.
- 일반적으로 다음으로 처리할 객체 정보를 유지하는 필드를 포함하는 작업 처리 추상 클래스로 의무 체인 패턴을 구성한다.

### 람다 + 의무 체인.
- 여러 함수형 인터페이스를 사용해서 클래스를 만들지 않고, 함수형 인터페이스 파이프라인으로 처리할 수 있다.

### 팩터리 패턴.
- 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 팩터리 디자인 패턴을 사용한다.
- 생성자와 설정을 외부로 노출하지 않음으로써 클라이언트가 단순하게 인스턴스를 생성할 수 있다.

### 람다 + 팩터리 패턴.
- Map<key, Supplier>을 key에 맞는 인스턴스를 제공하도록 만들 수 있다.
- 인스턴스에 대한 인자가 많은 경우 함수형 인터페이스를 새로 만들어야 한다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 람다 테스팅.

### 보이는 람다 표현식의 동작 테스팅.
- 람다는 익명 함수일므로 테스트 코드 이름을 호출할 수 없다.
- 필요하다면 람다를 필드에 저장해서 재사용할 수 있으며 람다의 로직을 테스트할 수 있다.

### 람다를 사용하는 메서드의 동작에 집중하라.
- 메서드 안에서 사용하는 람다는 메서드 자체를 테스트함으로써 확인할 수 있다.

### 복잡함 람다를 개별 메샤드로 분할하기.
- 복잡한 람다식은 메서드별로 분할하여 메서드참조 형식으로 테스트를 할 수 있다.

### 고차원 함수.
- 함수를 인자로 받거나 다른 함수를 반환하는 메서드를 의미한다.
- 19장에서 자세히 설명함.

### 고차원 함수 테스팅.
- 메서드가 람다를 인수로 받는다면 다른 람다로 메서드의 동작을 테스트할 수 있다.

-------------------------------------------------------------------------------------------------------------------------------

> ## 디버깅.

### 개요.
- 문제가 발생한 코드를 디버깅할 때 개발자는 다음 두 가지를 가장 먼저 확인해야 한다.
  - 스택 트레이스.
  - 로깅.
- 하지만, 람다 표현식과 스트림은 기존의 디버깅 기법을 무력화한다.

### 스택 트레이스 확인.
- 예외 발생으로 프로그램 실행이 갑자기 중단되었다면 먼저 어디에서 멈췄고 어떻게 멈추게 되었는지 살펴봐야 한다. (스택 프레임 확인)
- 메서드를 호출할 때마다 호출 위치, 호출할 때의 인수 값, 호출된 메서드의 지역 변수 등을 포함한 호출 정보가 스택 프레임에 저장.
- 따라서 프로그램이 멈췄다면 프로그램이 어떻게 멈추게 되었는지 프레임별로 보여주는 스택 트레이스를 얻을 수 있다.

### 람다 표현식의 스택 트레이스.
- 메서드 참조를 사용하는 클래스와 같은 곳에 선언되어 있는 메서드를 참조할 때는 메서드 참조 이름이 스택 트레이스에 나타난다.
- 나머지 경우에는 스택 트레이스를 이해하기 어렵다. (자바 컴파일러가 개선해야 될 부분이다)

### 정보 로깅.
- peek() 메서드를 통해 스트림의 요소를 확인할 수 있다.

### 최종 정리.
- 람다 표현식으로 가독성이 좋고 더 유연한 코드를 만들 수 있다.
- 익명 클래스는 람다 표현식으로 바꾸는 것이 좋다. 하지만 이때 this, 변수 새도 등 미묘하게 의미상 다른 내용이 있음을 주의하자.
- 메서드 참조로 람다 표현식보다 더 가독성이 좋은 코드를 구현할 수 있다.
- 반복적으로 컬렉션을 처리하는 루틴은 스트림 API로 대체할 수 있을지 고려하는 것이 좋다.
- 람다 표현식으로 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩터리 등의 객체지향 디자인 패턴에서 발생하는 불필요한 코드를 제거할 수 있다.
- 람다 표현식도 단위 테스트를 수행할 수 있다. 하지만, 람다 표현식 자체를 테스트하는 것보다는 람다 표현식 메서드의 동작을 테스트해라.
- 복잡한 람다 표현식은 일반 메서드로 재구현할 수 있다.
- 람다 표현식을 사용하면 스택 트레이스를 이해하기 어려워진다.
- 스트림 라이프라인에서 요소를 처리할 때 peek 메서드로 중간값을 확인할 수 있다.













