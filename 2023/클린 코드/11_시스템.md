
# 시스템

------------------------------------------------------------------------------------------------------------------------

> ## 시스템 제작과 시스템 사용을 분리하라

### 관심사 분리 concern
- 가장 오래되고 가장 중요한 설계 기법 중 하나이다


### 초기화 지연 Lazy Initialization
    public Service getService() {
        if (service == null) {
            service = new MyServiceImpl(...);   // 모든 상황에 적합한 기본값일까??
        }
        return service;
    }
- 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다
- 어떤 경우에도 null 포인터를 반환하지 않는다


### Main 분리
- 시스템 생성과 시스템 사용을 분리하는 한 가지 방법이다
- 생성과 관련된 코드는 모두 main, main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고, 모든 의존성이 연결되었다고 가정


### 팩토리
- 객체가 생성되는 시점이 어플리케이션이 결정하는 경우


### 의존성 주입 Dependency Injection
- 사용과 제적을 분리하는 강력한 메커니즘
- 제어의 역전 기법을 의존성 관리에 적용한 메커니즘


### 제어의 역전 IoC Inversion of Control
- 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다
- 초기 설정은 시스템 전체에서 필요하므로 대개 '책임질' 메커니즘으로 main 루틴이나 특수 컨테이너를 사용한다


### JNDI 검색
    MyService myService = (MyService) ( jndiContext.lookup("NameOfMyService") );
- 의존성 주입을 '부분적으로' 구현한 기능


### 진정한 의존성 주입
- DI 컨테이너는 (대게 요청이 들어올 때마다) 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정한다


### 스프링 프레임워크
- 자바에서 사용하는 DI 컨테이너이다
- 객체 사이 의존성은 XML 파일 또는 어노테이션 등을 통해 정의
- 계산 지연이나 비슷한 최적화 방법을 사용해 팩토리를 호출하거나 프록시를 생성하는 방법을 통해 '초기화 지연'한다

------------------------------------------------------------------------------------------------------------------------

> ## 확장

### 올바른 설계
- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 잘못된 생각이다
- 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다
- TDD, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다

------------------------------------------------------------------------------------------------------------------------

> ## AOP

### 자바 프록시
- 단순한 상황에 사용
- JDK에서 제공하는 프록시는 인터페이스만 제공한다
- 실제 코드를 변경하는 클래스 프록시를 사용하려면 CGLIB, ASM, Javassist 등과 같은 바이트 코드 처리 라이브러리가 필요하다


### POJO
- 엔터프라이즈 프레임워크에 의존하지 않은 순수 자바 코드이다
- 상대적으로 단순하기 때문에 코드를 보수하고 개선하기 편하다


### AspectJ
- 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어확장이다
- AspectJ는 관점을 분리하는 강력하고 풍부한 도구 집합을 제공하긴 하지만, 새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다

------------------------------------------------------------------------------------------------------------------------

> ## 테스트 주도 시스템 아키텍처 구축

### 테스트 주도 아키텍처 구축
- 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다
- 그때그때 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍처로 키워갈 수도 있다


### 의사 결정을 최적화하라
- 모듈을 나누고 관심사를 붑ㄴ리하면 지엽적인 관리와 결정이 가능해진다
- 가능한 마지막 순간까지 결정을 미루는 방법이 최선일 수 있다 (최대한 정보를 모아 최선의 결정을 내리기 위해)


### 정리
- 최선의 시스템 구조는 각기 POJO로 구현되는 모듈화된 관심사 영역으로 구성된다
- 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다

------------------------------------------------------------------------------------------------------------------------

> ## 명백한 가치가 있을 때 표준을 현명하게 사용하라

### 표준 사용 장점
- 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽다
- 적절한 경험을 가진 사람을 구하기 쉽다
- 좋은 아이디어를 캡슐화하기 쉽다
- 컴포넌트를 엮기 쉽다


### 표준 사용 단점
- 표준을 만드는 시간이 너무 오래 걸릴 수 있다
- 원래 표준을 제정한 목적을 잊어버릴 수도 있다

------------------------------------------------------------------------------------------------------------------------

> ## 시스템은 도메인 특화 언어가 필요하다

### DSL Domain Specific Language
- 간단한 스크립트 언어나 표준 언어로 구현한 API
- DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힌다


### 결론
- 시스템 역시 깨끗해야 한다
  - 깨긋하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다
  - 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다
  - 도메인 논리가 흐려지면 제품 품질이 떨어진다
- 모든 추상화 단계에서 의도는 명확히 표현해야 한다
- 실제로 돌아가는 가장 단순한 수단을 사용해야 한다






















