
# 스트림 소개.

--------------------------------------------------------------------------------------------------------------------------------

> ## 스트림이란 무엇인가 ?

### 스트림.
- 자바8에 새로 추가된 기능이다.
- 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다. (데이터를 처리하는 임시 구현 코드 -> 질의)
- 스트림이 데이터 컬렉션 반복을 멋지게 처리하는 기능이라고 생각하자.
- 스트림을 활용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다. (7장)

### 스트림 활용.
    // 스트림으로 정렬하고 이름 리스트로 반환.
    List<String> lowCaloricDishesName = menu.stream()
                                            .filter(d -> d.getCalories() < 400)
                                            .sorted(comparing(Dish::getCalories))
                                            .map(Dish::getName)
                                            .collect(toList());
    // 병렬 처리.
    List<String> lowCaloricDishesName = menu.parallelStream()
                                            .filter(d -> d.getCalories() < 400)
                                            .sorted(comparing(Dish::getCalories))
                                            .map(Dish::getName)
                                            .collect(toList());

### 선언형 코드.
- 어떻게(How)는 감추고, 무엇을(what)에 집중하는 코드 작성 방식을 의미한다.

### parallelStream()을 사용했을 때 얻는 이점.
- 선언형으로 코드를 구현할 수 있다. (루프, if 조건문 등의 제어 블록 제거)
- filter, sorted, map, collect 같은 여러 빌딩 블록 연산을 연결해서 데이터 처리 파이프라인을 만들 수 있다. (고수준 빌딩 블록)
- 자세한 내용은 7장에서 배운다.

### 컬렉션을 제어하는 라이브러리.
- 구아바 Guava : 멀티맵, 멀티셋 등 추가적인 컨테이너 클래스를 제공한다.
- 아파티 공통 걸렉션 Apache Commons Collections : 구아마와 거의 흡사하다.
- 람다제이 lambdaj : 함수형 프로그래밍에서 영감을 받은 선언형으로 컬렉션을 제어하는 다양한 유틸리티를 제공.

### 자바 8 스트림 API 특징.
- 선언형 : 더 간결하고 가독성이 좋아진다.
- 조립할 수 있음 : 유연성이 좋아진다.
- 병렬화 : 성능이 좋아진다.

--------------------------------------------------------------------------------------------------------------------------------

> ## 스트림 시작하기.

### 스트림이란?
- 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소 'Sequence of elements'로 정의할 수 있다.
- 연속된 요소.
  - 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
  - 컬렉션에서는 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. (데이터)
  - 스트림에서는 filter, sorted, map처럼 표현 계산식이 주를 이룬다. (계산)
- 소스.
  - 컬렉션, 배열, I/O 자원 듣의 데이터 제공 소스로부터 데이터를 소비한다.
  - 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
  - 즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.
- 데이터 처리 연산.
  - 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
  - filter, map, reduce, find, match, sort 등으로 데이터를 조작할 수 있다.
  - 스트림 연산은 순차적으로 또는 병렬로 실행할 수 있다.

### 스트림 두 가지 주요 특징.
- 파이프라이닝 Pipelining.
  - 스트림 연산은 스트림 영ㄴ산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다.
  - 게으름 laziness, 쇼트서킷 short-circuiting 같은 최적화를 활용할 수 있다.
  - 연산 파이프라인은 데이터 소스에 적용하는 데이터베이스 질의와 비슷하다.
- 내부 반복.
  - 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.
  - 4.3.2절에서 내부 반복을 자세히 설명한다.

### 스트림 연산.
- filter.
  - 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다.
  - dish -> dish.getCalories() > 300은 300 칼로리 이상의 요리를 선택한다.
- map.
  - 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다.
  - Dish::getName은 각각의 요리명을 추출한다.
- limit.
  - 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소 truncate한다.
- collect.
  - 스트림을 다른 형식으로 변환한다.
  - 예제에서는 스트림을 리스트로 변환했다.
  - Collectors.toList()는 스트림을 리스트로 변환하라고 지시하는 인수다.

--------------------------------------------------------------------------------------------------------------------------------

> ## 스트림과 컬렉션.

### 연속된 sequenced.
- 순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근한다는 것을 의미한다.

### 컬렉션과 스트림의 차이.
1. 데이터를 언제 계산하는지.
   - 컬렉션. 
     - 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조. (supplier-driven)
     - 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. (컬렉션의 모든 요소를 메모리에 저장한 뒤 컬렉션에 추가하려는 요소를 미리 계산)
   - 스트림.
     - 요청할 때만 요소를 계산하는 고정된 자료구조. (스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없다)
     - 사용자가 요청하는 값만 스트림에서 추출한다. (생상자 소비자 관계 형성)
     - 즉, 사용자가 데이터를 요청할 때 값을 계산한다. (demand-driven manufacturing, just-in-time manufacturing)
2. 탐색하는 횟수.
   - 컬렉션.
     - 여러번 탐색 가능. 
   - 스트림.
     - 탐색된 스트림의 요소는 소비된다.
     - 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.
3. 외부 반복과 내부 반복.
   - 컬렉션 (external iteration)
     - 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. (for-each)
     - 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다. (외부 반복)
     - 외부 반복은 병렬성을 스스로 처리해야 한다.
   - 스트림 (internal iteration)
     - 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해준다.
     - 함수에 어떤 작업을 수행할지만 지정하면 모든 것이 알아서 처리된다.
     - 선언적으로 처리할 수 있다.
     - 내부 반복은 병렬성을 쉽게 처리할 수 있다.

### 내부 반복의 특징.
- 병렬로 처리할 수 있다.
- 요소들을 정렬하는 등의 방법을 통해 다양한 방법으로 처리할 수 있다.
  - filter나 map 같은 반복을 숨겨주는 연산 리스트가 정의되어 있어야 활용할 수 있다.

--------------------------------------------------------------------------------------------------------------------------------

> ## 스트림 연산.

### 스트림 연산의 종류.
1. 중간 연산 intermediate operation.
2. 최종 연산 terminal operation.

### 중간 연산.
- 연결할 수 있는 스트림 연산.
- filter나 sorted 같은 중간 연산은 다른 스트림을 반환한다.
- 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다.
- 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문이다. (lazy)

### 쇼트 서킷.
- 논리연산자와 조합된 다른 연산식이나 조건식이 생략되는 경우를 쇼트서킷이라고 부른다.

### 루프 퓨션 loop fusion.
- filter와 map 같은 서로 다른 중간 연산자들이 한 과정으로 병합되어 실행되는 것을 의미한다.

### 최종 연산.
- 최종 연산은 스트림 파이프라인에서 결과를 도출한다.
- 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다.

### 스트림 이용 과정.
1. 질의를 수행할(컬렉션) 데이터 소스.
2. 스트림 파이프라인을 구성할 중간 연산 연결.
3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산.

### 스트림 특징.
- 스트림 파이프라인의 개념은 빌더 패턴과 비슷하다.
- 빌더 패턴에서는 호출을 연결하여 설정을 만든 후에 준비된 설정에 build 메서드를 호출한다.

### 중간 연산.
- Stream<T> filter(Predicate<T>);
- Stream<R> map(Function<T,R>);
- Stream<T> limit(int i);
- Stream<T> sorted(Comparator<T>);
- Stream<T> distinct();

### 최종 연산.
- void forEach(수행할 코드);
- long count(수행할 코드);
- 콜렉션 collect(반환할 타입)

--------------------------------------------------------------------------------------------------------------------------------

> ## 로드맵.

### 정리.
- 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원한다.
- 스트림은 내부 반복을 지원한다. 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화한다.
- 스트림에는 중간 연산과 최종 연산이 있다.
- 중간 연산은 filter와 map처럼 스트림을 반환하면서 다른 연산과 연결되는 연산이다.
- 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성할 수 없다.
- forEach나 count처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 한다.
- 스트림의 요소는 요청할 때 게으르게 lazily 계산된다.





















 