
# 리액티브 프로그래밍.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 리액티브 매니패스토. 

### 프로그래밍의 변화.
- 빅데이터 : 보통 빅데이터는 페타바이트 단위로 구성되며 매일 증가한다.
- 다양한 환경 : 모바일 디바이스에서 수천 개의 멅티 코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 배포된다.
- 사용 패턴 : 사용자는 1년 내내 항상 서비스를 이용할 수 있으며 밀리초 단위의 응답 시간을 기대한다.


### 리액티브 매니패스토 reactive manifesto.
- 2013 ~ 2014년에 걸쳐 개발되었으며 리액티브 어플리케이션과 시스템 개발의 핵심 원칙을 공식적으로 정의한다.


### 리액티브 매니패스토 원칙.
- 반응성 responsive.
  - 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다.
  - 결과적으로 사용자가 기대치를 가질 수 있다.
  - 기대치를 통해 사용자의 확신이 증가하면서 사용할 수 있는 어플리케이션이라는 확인을 제공할 수 있다.
- 회복성 resilient.
  - 장애가 발생해도 시스템은 반응해야 한다.
  - 회복성을 달성할 수 있는 다양한 기법을 제시한다.
- 탄력성 elastic.
  - 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
- 메시지 주도 Message-driven.
  - 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이루어진다.
  - 이 덕분에 회복성과 탄력성을 얻을 수 있다.


### 어플리케이션 수준의 리액티브.
- 어플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 주요 기능은 비동기로 작업을 수행할 수 있다는 점이다.
- 이들 기술은 쓰레드보다 가벼울 뿐 아니라 개발자에게 큰 이득을 제공한다.
- 개발자 입장에서는 동기 블록, 경쟁 조건, 데드락 같은 저 수준의 멀티쓰레드 문제를 직접 처리할 필요가 없어진다.
- 쓰레드를 다시 쪼개는 종류의 기술을 이용할 때는 메인 이벤트 루프 안에서는 절대 동작을 블럭하지 않아야 한다는 중요한 전제 조건이 따른다.


### 리액티브 시스템.
- 여러 어플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해준다.
- 이들 어플리케이션 중 하나가 실패해도 전체 시스템은 계속 운여될 수 있도록 도와주는 소프트웨어 아키텍처이다.


### 시스템 수준의 리액티브.
- 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 주변의 다른 컴포넌트로 전파되면서 전체 시슽쳄 장애로 이어지는 것을 막는다.
- 이런 맥락에서 회복성은 결함 허용 능력(fault tolerance)와 같은 의미를 가진다.


### 위치 투명성.
- 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든 서비스와 통신할 수 있음을 의미한다.
- 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 어플리케이션을 확장할 수 있다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 리액티브 스트림과 플로 API.

### 리액티브 스트림.
- 리액티브 프로그래밍은 리액티브 스트림을 사용하는 프로그래밍이다.
- 잠재적으로 무한의 비동기 데이터를 순서대로 그리고 블록하지 않은 역압력을 전제해 처리하는 표준 기술이다.


### 역압력.
- 이벤트 스트림의 구독자가 발행자 이벤트를 제공하는 속도보다 느린 속도로 이벤트를 소비하면서 문제가 발생하지 않도록 보장하는 장치.
    1. 부하가 발생한 컴포넌트는 이벤트 발생ㅎ 속도를 늦추라고 알린다.
    2. 얼마나 많은 이벤트를 수신할 수 있는지 알린다.
    3. 다른 데이터를 받기 전에 기존의 데이터를 처리하는 데 얼마나 시간이 걸리는지를 업스트림 발행자에게 알린다.


### Flow 클래스 종류.
- Publisher
- Subscriber
- Subscription
- Processor


### Publisher 인터페이스.
    @FunctionalInterface
    public interface Publisher<T> {
        void subscribe(Subscriber<? super T> s);
    }
- 항목을 발행한다.
- Publisher는 수많은 이벤트를 제공할 수 있지만 Subscriber의 요구사항에 따라 역압력 기법에 의해 이벤트 제공 속도가 제한된다.


### Subscriber 인터페이스.
    public interface Subscriber<T> {
        void onSubscribe(Subscription s);
        void onNext(T t);
        void onError(Throwable t);
        void onComplete();
    }
- Publisher가 발행한 항목을 한 개 또는 여러개 소비한다.
- Publisher가 발행한 이벤트의 리스너로 자신을 등록할 수 있다.
- onSubscribe() 메서드는 항상 처음 호출된다.
- onNext()는 여러 번 호출 될 수 있다.
- onComplete() 콜백을 통해 더 이상의 데이터가 없고 종료됨을 알릴 수 있다.
- onError()는 Publisher에 장애가 발생했을 때 호출할 수 있다. (I/O 에러와 비슷하다)


### Subscription 인터페이스.
    public interface Subscription {
        void request(long n);
        void cancel(); 
    }
- Subscription은 Publisher와 Subscriber 사이의 제어 흐름, 역압력을 관리한다.
- request()는 Publisher에게 주어진 개수의 이벤트를 처리할 준비가 되었음을 알릴 수 있다.
- cancel() 메서드는 Subscription 취소, 즉 Publisher에게 더 이상 이벤트를 받지 않음을 통지한다.


### 플로 명세서 규칙 집합.
- Publisher는 반드시 Subscription request()에 정의된 개수 이하의 요소만 Subscriber에 전달해야 한다.
- Subscriber는 요소를 받아 처리할 수 있음을 Publisher에게 알려야 한다.
  - Subscriber가 관리할 수 없이 너무 많은 요소를 받는 일을 피할 수 있다.
  - onComplete(), onError()를 처리하는 상황에서 Subscriber는 Publisher, Subscription의 메서드를 호출할 수 없다. (Subscription의 취소와 같다)
  - Subscriber는 Subscription.request() 메서드 호출이 없이도 언제든 종료 시그널을 받을 준비가 되어있어야 한다.
  - Subscription.cancel()이 호출된 이후에라도 한 개 이상의 onNext()를 받을 준비가 되어 있어야 한다.
- Publisher와 Subscriber는 정확하게 Subscription을 공유해야 하며 각각이 고유한 역할을 수행해야 한다.
  - onSubscribe(), onNext() 메서드에서 Subscriber는 reuqest() 메서드를 동기적으로 호출할 수 있어야 한다.
  - Subscription.cancel() 메서드는 몇 번을 호출해도 한 번 호출한 것과 같은 효과를 가져야 한다.


### Processor 인터페이스.
    public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { }
- Publisher, Subscriber를 상속받을 뿐 아무 메서드도 추가하지 않는다.
- Processor가 에러를 수신하면 이로부터 회복하거나 즉시 onError 신호로 모든 Subscriber에 에러를 전파할 수 있다.
- Subscriber가 Subscription을 취소하면 Processor는 자신의 업스트림 Subscription도 취소함으로 취소 신호를 전파해야 한다.


### Flow API 특이점.
- Flow API는 인터페이스의 구현체를 제공하지 않는다.
- Flow API를 만들 당시 Akka, RxJava 등 다양한 리액티브 스트림의 자바 코드 라이브러리가 존재해서 구현체를 만들지 않았다.
- 리액티브 스트림 구현을 만드는 것은 복잡한 일이므로 대부분의 사용자는 단순히 기존 구현을 사용할 것이다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 리액티브 라이브러리 RxJava 사용하기.

### RxJava.
- 자바로 리액티브 어플리케이션을 구현하는 데 사용하는 라이브러리다.
- Flow API를 지원하도록 RxJava 2.0 버전이 개발되었다.


### RxJava 처음 시작하기.
    // 의존성 추가
    <dependency>
      <groupId>io.reactivex.rxjava2</groupId>
      <artifactId>rxjava</artifactId>
      <version>2.2.19</version>
    </dependency>


### 마블 다이어 그램 marble diagram.
- 시각적 방법을 이용해 리액티브 스트림을 표현하기 위한 방법.
- 수평선으로 표시된 리액티브 스트림에 임의의 순서로 구성된 요소가 기하학적 모형이 나타난다.

------------------------------------------------------------------------------------------------------------------------------------------

> ## 정리.

### 최종 정리.
- 리액티브 프로그래밍의 기초 사상은 이미 20~30년 전에 수립되었지만 데이터 처리량과 사용자 기대치 덕분에 최근에서 인기를 얻고 있따.
- 리액티브 소프트웨어의 네가지 특성(반응성, 회복성, 탄력성, 메시지 주도)을 서술하는 리액티브 매니페스토가 리액티브 프로그래밍을 공식화 한다.
- 여러 어플리케이션을 통합하는 리액티브 시스템과 한 개의 어플리케이션을 구현할 때에 각각 다른 접근 방식으로 리액티브 프로그래밍 원칙을 적용.
- 리액티브 스트림은 비동기적으로 처리되므로 역압력 기법이 기본적으로 탑재되어 있다.
- 역압력은 발행자가 구독자보다 빠른 속도로 아이템을 발행하므로 발생하는 문제를 방지한다.
- Flow API는 Publisher, Subscriber, Subscription, Processor 네 개의 핵심 인터페이스를 정의한다.
- 가장 흔한 리액티브 프로그래밍 도구로 RxJAva를 꼽을 수 있으며 Flow API의 기본 기능에 더해 다양한 연상자를 제공한다.






























