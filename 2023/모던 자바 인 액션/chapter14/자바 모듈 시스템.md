
# 자바 모듈 시스템

---------------------------------------------------------------------------------------------------------------------------------

> ## 압력 : 소프트웨어 유추.

### 모듈.
- 소프트웨어 설계에서 기능단위로 분해하고 추상화되어 재사용 및 공유 가능한 수준으로 만들어진 단위.


### 모듈화.
- 소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하도록 하는 소프트웨어 설계 기법.


### 관심사 분리 SoC Separation of Concerns.
- 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.
- 클래스를 그룹화한 모듈을 이용해 어플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다.


### SoC 원칙.
- 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다.


### SoC 원칙의 장점.
- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
- 개별 부분을 재사용하기 쉽다.
- 전체 시스템을 쉽게 유지보수할 수 있다.


### 정보 은닉.
- 세부 구현을 숨기도록 장려하는 원칙이다.
- 세부 구현을 숨기으로 프로그램의 어떤 부분을 바꿧을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다.


### 캡슐화 encapsulation.
- 특정 코드 조각이 다른 어플리케이션의 다른 부분과 고립되어 있음을 의미한다.
- 캡슐화된 코드의 내부적인 변화는 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다.


### 자바 9버전 이전.
- 자바 9버전 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수 있는 기능이 없었다.


### 잘 설계된 소프트웨어.
- 잘 설계된 소프트웨어는 관심사 분리와, 정보 은닉 원칙을 따르는 것이 필수다.
- 자바에서는 UML 다이어그램같은 도구를 이용해 소프트웨어를 추론하는데 도움이 될 수 있다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 자바 모듈 시스템을 설계한 이유.

### 모듈화의 한계.
- 자바 9이전까지는 모듈화된 소프트웨어 프로젝트를 만드는 데 한계가 있었다.
- 자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다.


### 제한된 가시성 제어.
- 클래스 간의 가시성은 접근 제어자를 통해 제어한다.
- 패키지 간의 가시성은 따로 제어할 수 있는 방법이 없다.


### 클래스 경로의 단점.
1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
   - 다양한 컴포넌트가 같은 라이브러리의 다른 버전을 사용하는 상황이 발생할 수 있는 경우 문제가 발생할 수 있다.
2. 클래스 경로는 명시적인 의존성을 지원하지 않는다.
   - 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다.


### 컴팩트 프로파일 compact profiles.
- 관련 분야에 따라 JDK 라이브러리가 세 가지 프로파일로 나뉘어 각각 다른 메모리 풋프린트를 제공한다.


### 거대한 JDK 단점.
- 자바 언어의 낮은 캡슐화 지원 때문에 내부 API가 외부에 공개되었다.


### 모듈화 시스템의 필요성.
- JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며, 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 
  제공할 새로운 건축 구조가 필요했다.


### OSGi Open Service Gateway initiative.
- 자바에서 사용할 수 있는 모듈 시스템. (자바 플랫폼의 공식 기능은 아니다)
- OSGi와 새로운 자바 9 모듈 시스템은 상호 배타적인 관계가 아니다. (공존 가능)
- OSGi는 훨씬 더 광범위한 영역을 가지며 직소에서 제공하지 않는 여러 기능을 제공한다.
- 번들이라 불리는 OSGi 모듈은 특정 OSGi 프레임워크 내에서만 실행된다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 자바 모듈 : 큰 그림.

### 자바 8 모듈.
- 자바 8은 모듈이라는 새로운 자바 프로그램 구조 단위를 제공한다.
- 모듈ㅇ느 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다.


### 모듈 디스크립터 module descriptor.
- module-info.java 라는 특별한 파일에 저장된다.
- 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다.


### 자바 모듈 디스크립터의 핵심 구조. (module-info.java)
    module 모듈명 {
        exports 패키지명
        required 모듈명
    }
- module 모듈명 : 정의하려는 모듈을 의미한다.
- exports 패키지명 : 한 모듈이 제공하는 패키지를 다른 모듈에서 사용할 수 있도록 공개하는 것을 의미한다.
- required 모듈명 : 한 모듈이 다른 모듈의 패키지를 사용하도록 요구하는 것을 의미한다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 자바 모듈 시스템으로 어플리케이션 개발하기.

### 세부적인 모듈화와 거친 모듈화.
- 시스템을 모듈화할 때 모듈 크기를 결정해야 한다.


### 세부적인 모듈화.
- 세부적인 모듈화 기법 대부분은 모든 패키지가 자신의 모듈을 갖는다.
- 이득에 비해 설계 비용이 증가한다.


### 거친 모듈화.
- 거친 모듈화 기법 대부분은 한 모듈이 시스템의 몯느 패키지를 포함한다.
- 모듈화의 모든 장점을 잃는다.


### 자바 모듈 시스템 기초.
- module-info.java은 모듈의 소스 코드 파일 루트에 위치해야 하며, 모듈의 의존성과 어떤 기능을 외부로 노출할지를 정의한다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 여러 모듈 활용하기.

### exports 구문.
    module expenses.readers {
        exports com.example.expenses.readers;           // 패키지명.
        exports com.example.expenses.readers.file;
        exports com.example.expenses.readers.http;
    }
- exports는 다른 모듈에서 사용할 수 있도록 특정 패키지를 공개 형식으로 만든다.
- 모듈 시스템은 화이트 리스트 기법을 이용해 강력한 캡슐화를 제공하므로 다른 모듈에서 사용할 수 있는 기능이 무엇인지 명시적으로 결정해야 한다.


### requires 구문.
    module expenses.readers {
        requires java.base;         // 모듈명
        ...
    }
- requires는 의존하고 있는 모듈을 지정한다.
- java.base 외의 모듈을 임포트할 때 requries를 사용한다.


### java.base
- 모든 모듈은 java.base라는 플랫폼 모듈에 의존한다.
- 이 플랫폼 모듈은 net, io, util 등의 자바 메인 패키지를 포함한다.
- 항상 기본적으로 필요한 모듈이므로 java.base는 명시적으로 정의할 필요가 없다.


### 이름 정하기.
- 모듈이 패키지를 포함하지 않거나 어떤 다른 이유로 노출된 패키지 중 하나의 이름이 일치하지 않는 상황을 제외하면 모듈명은 도메인 명 역순을 사용.

---------------------------------------------------------------------------------------------------------------------------------

> ## 컴파일과 패키징.

### 메이븐으로 컴파일하기.
- module-info.java는 src/main/java 디렉터리에 위치한다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 자동 모듈.

### 자동 모듈.
- 자바에 내부 모듈이 아닌 외부 라이브러리를 pom.xml과 module-info.java 설정을 통해 내부 모듈처럼 모듈화할 수 있다.
- 이러한 기능을 자동 모듈이라고 한다.
- 자동 모듈은 암묵적으로 자신의 패키지를 노출시킨다.
- 자동 모듈의 이름은 JAR 이름을 이용해 정해진다.
- jar 도구의 --describe -module 인수를 이용해 자동으로 정해지는 이름을 바꿀 수 있다.

---------------------------------------------------------------------------------------------------------------------------------

> ## 모듈 정의와 구문들.

### module-info.java에서 사용할 수 있는 구문들.
- requires-transitive, exports-to, open, opens, users, provides 등 여러가지 다른 구문들이 있다.


### requires
    module com.iteratrlearning.application {
        requires com.iteratrlearning.ui;
    }
- requires 구문은 컴파일 타임과 런타임에 한 모듈이 다른 모듈에 의존함을 정의한다.
- application은 ui 모듈에 의존한다.
- 그러면, ui에서 외부로 노출한 공개 형식을 application에서 사용할 수 있다.
- 기본형식은 requires [모듈명]이다.


### exports
    module com.iteratrlearning.ui {
        requires com.iteratrlearning.core;
        exports com.iteratrlearning.ui.panels;
        exports com.iteratrlearning.ui.widgets;
    }
- exports 구문은 지정한 패키지를 다른 모듈에서 이용할 수 있도록 공개 형식으로 만든다.
- 아무 패키지도 공개하지 않는 것이 기본 형식이다.
- 어떤 패키지를 공개할 것인지를 명시적으로 지정함으로 캡슐화를 높일 수 있다.
- 기본형식은 exports [패키지명]이다.


### requires transitive.
    module com.iteratrlearning.ui {
        requires transitive com.iteratrlearning.core;
        ...
    }
- 다른 모듈이 제공하는 공개 형식을 한 모듈에서 사용할 수 있다고 지정할 수 있다.
- 전이성 선언을 통해 ui를 requires 하는 모듈은 core 모듈의 공개 형식에 접근할 수 있다.


### exports to.
    module com.iteratrlearning.ui {
        requires com.iteratrlearning.core;

        ...
        exports com.iteratrlearning.ui.widgets to com.iteratrlearning.ui.widgetuser;
    }
- exports to 구문을 이용해 사용자에게 공개할 기능을 제한함으로 가시성을 좀 더 정교하게 제어할 수 있다.
- widgets의 접근 권한을 가진 사용자의 권한을 widgetuser로 제한할 수 있다.


### open과 opens.
    open module com.iteratrlearning.ui {

    }
- open 한정자를 이용하면 모든 패키지를 다른 모듈에 반사적으로 접근을 허용할 수 있다.
- open 한정자는 모듈의 가시성에 다른 영향을 미치지 않는다.
- 자바 9 이전에는 리플렉션으로 객체의 private 상태를 확인할 수 있었다.
- 자바 9에서는 기본적으로 리플렉션이 이런 기능을 허용하지 않는다. (open 구문을 명시적으로 사용하면 가능)
- oepn to 구문을 통해 특정 모듈에만 리플렉션 접근을 허용할 수 있다.


### uses와 provides.
- provides 구문으로 서비스 제공자를 지정하고, uses 구문으로 서비스 소비자를 지정할 수 있는 기능을 제공한다.
- 자세한 내용은 The Java Module System을 살펴봐라.

---------------------------------------------------------------------------------------------------------------------------------

> ## 마무리.

### 모듈 시스템.
- 자바 9 이상의 버전에서는 자바 EE와 관련된 여러 패키지가 모듈화도니 자바 9 가상 머신에서 기본적으로 로드되지 않는다. (JAXB API)
- 자바 모듈 시스템을 더 자세히 알고 싶다면 따로 공부를 해야 한다.


### 정리.
- 관심사분리와 정보 은닉은 추론하기 쉬운 소프트웨어를 만드는 중요한 두 가지 원칙이다.
- 자바 9 이전에는 각각의 기능을 담당하는 패키지, 클래스, 인터페이스로 모듈화를 구현했는데 효과적ㅇ니 캡슐화를 달성하기에는 역부족이었다.
- 클래스 경로 지옥 문제는 어플리케이션의 의존성을 추론하기 더욱 어렵게 만들었다.
- 자바 9 이전의 JDK는 거대했으며 높은 유지 비용과 진화를 방해하는 문제가 존재했다.
- 자바 9에서는 새로운 모듈 시스템을 제공하는데 module-info.java 파일은 모듈의 이름을 지정하며 필요한 의존성과 공개 API를 정의한다.
- requires 구문으로 필욯나 다른 모듈을 정의할 수 있다.
- exports 구문으로 특정 패키지를 다른 모듈에서 사용할 수 있는 공개 형식으로 지정할 수 있다.
- 인터넷 도메인명을 역순으로 사용하는 것이 권장 모듈 이름 규칙이다.
- 모듈 경로에 포함된 JAR 중에 module-info 파일을 포함하지 않는 모든 JAR는 자동 모듈이 된다.
- 자동 모듈은 암묵적으로 모든 패키지를 공개한다.
- 메이븐은 자바 9 모듈 시스템으로 구조화된 어플리케이션을 지원한다.
















