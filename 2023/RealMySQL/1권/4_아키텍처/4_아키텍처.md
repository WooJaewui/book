
# 아키텍처

---------------------------------------------------------------------------------------------------------------------------------------

> ## MySQL 엔진 아키텍처

### MySQL 서버 구조
- MySQL 엔진
  - 사람의 머리 역할을 담당
- 스토리지 엔진
  - 사람의 손발 역할을 담당
  - 핸들러 API를 만족하면 누구든지 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있다


### MySQL 전체 구조
- 프로그래밍 API
  - 파이썬, 자바, php, C++, ... 등
- MySQL 엔진
  - 커넥션 핸들러
  - SQL 인터페이스
  - SQL 파서
  - SQL 옵티마이저
  - 캐시 & 버퍼
- 스토리지 엔진
  - 스토리지 엔진 API
    - InnoDB
    - MYISAM
    - Memory
- 운영체제, 하드웨어
  - 데이터 파일
  - 로그 파일


### MySQL 엔진
- 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러 SQL 파서 및 전 처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다
- 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행될 수 있다


### 스토리지 엔진
- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다
- MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다


### 스토리지 엔진 사용 예제
    CREATEE TAGBLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
- 예제와 같이 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리한다


### 핸들러 API
- 핸들러 요청
  - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 말한다
- 핸들러 API
  - 핸들러 요청에서 사용되는 API를 의미한다
  

### 핸들러 API 요청 확인
    SHOW GLOBAL STATUS LIKE 'Handler%';
- Handler_Commit 몇회
- Handler_delete 몇회
- Handler_discover 몇회
- ...


### MySQL 서버 실행 구조
- MySQL 서버는 쓰레드 기반으로 작동한다
- 분류
  - 포그라운드 쓰레드 Foreground thread
  - 백그라운드 쓰레드 Background thread


### 포그라운드 쓰레드(클라이언트 쓰레드)
- 포그라운드 쓰레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 쓰레드는 다시 쓰레드 캐시로 되돌아간다
- 이미 쓰레드 캐시에 일정 개수 이상의 대기 중인 쓰레드가 있으면 쓰레드 캐시에 넣지 않고 쓰레드를 종료시켜 일정 개수만 캐시에 존재하게 한다
  - thread_cache_size : 최대 쓰레드 개수(시스템 변수)
- 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크 또는 인덱스 파일로부터 데이터를 읽어온다
- MyISAM 테이블
  - 디스크 쓰기 작업까지 포그라운드 쓰레드가 처리한다(지연된 쓰기가 있지만 일반적이지 않다)
- InnoDB 테이블
  - 데이터 버퍼나 캐시까지만 포그라운드 쓰레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 쓰레드가 처리한다


### 백그라운드 쓰레드
- InnoDB 백그라운드 사용
  - 인서트 버퍼를 병합하는 쓰레드 
  - 로그를 디스크로 기록하는 쓰레드 (중요)
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 쓰레드 (중요)
  - 데이터를 버퍼로 읽어 오는 쓰레드
  - 잠금이나 데드락을 모니터링하는 쓰레드
- 쓰기 버퍼링
  - InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 버퍼링을 하기 때문에 저장될 때까지 기다리지 않아도 된다
  - MyISAM에서는 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다


### 버퍼링 Buffering
- 한 작업의 계싼과 함께 입/출력을 동시에 수행하는 방법
- 입력 버퍼링
  - 프로세스가 데이터를 요구하기 전에 입력장치가 데이터를 주기억장치에 복사
- 출력 버퍼링
  - 데이터를 주기억장치에 저장하고 프로세스가 실행을 계속하는 동안에 장치에 데이터를 기록
  - 데이터를 입력한 후, CPU가 이를 연산하려고 하는 순간 CPU와 입력 장치는 동시에 동작되며, 양쪽의 속도가 비슷하다면 버퍼 이용이 효율적


### MySQL 메모리 공간
- 분류
  - 글로벌 메모리 영역
    - 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다
    - 운영체제에 따라 요청된 메모리를 100% 할당해줄 수도 있고, 그 공간만큼 예약해두고 필요할 때 조금씩 할당해주는 경우도 있다 
  - 로컬 메모리 영역
  - 분류 방법
    - MySQL 서버 내에 존재하는 많은 쓰레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다


### 글로벌 메모리 영역
- 일반적으로 클라이언트 쓰레드의 수와 무관하게 하나의 메모리 공간만 할당된다
- 단, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 쓰레드 수와는 무관하다
- 글로벌 메모리 공간의 개수가 늘어나도 글로벌 메모리 공간은 모든 쓰레드에 의해 공유된다
- 종류
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDb 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼


### 로컬 메모리 영역 (세션 메모리 영역)
- MySQL 서버상에 존재하는 클라이언트 쓰레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다
- 각 클라이언트 쓰레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우 MySQL이 메모리 공간을 할당하지 않을 수 있다
- 종류
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

---------------------------------------------------------------------------------------------------------------------------------------

> ## 플러그인 스토리지 엔진 모델

### 플러그인 모델
- MySQL의 독특한 구조 중 대표적인 것 중 하나이다
- 스토리지 엔진 이외에 전문 검색 엔진을 위한 검색어 파서(인덱싱할 키워드를 분리해내는 작업)도 플러그인 형태로 개발해서 사용할 수 있다


### MySQL 쿼리 실행 과정
1. SQL 파서
2. 옵티마이저
3. SQL 실행기
4. 데이터 읽기/쓰기
5. 디스크


### 핸들러
- 어떤 기능을 호출하기 위해 사용하는 운전대와 같은 역할을 하는 객체
- MySQL에서는 MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다
  - 'Handler_'로 시작하는 상태 변수는 'MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수'이다


### MySQL 명령어
    // 스토리지 엔진 확인하기
    SHOW ENGINES;

    // 플러그인 확인하기
    SHOW PLUGINS;


### Support 컬럼에 표시
- YES : MySQL 서버에 해당 스토리지 엔진이 포함돼 있고, 사용 가능으로 활성화된 상태임
- DEFAULT : 'YES'와 동일한 상태이지만 필수 스토리지 엔진임을 의미함(이 스토리지 엔진이 없으면 MySQL이 시작되지 않을 수도 있음)
- NO : 현재 MySQL 서버에 포함되지 않았음을 의미함
- DISABLED : 현재 MySQL 서버에는 포함됐지만 파라미터에 의해 비활성화된 상태임

---------------------------------------------------------------------------------------------------------------------------------------

> ## 컴포넌트

### MySQL 변화
- MySQL 80부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다
- MySQL 서버의 플러그인은 단점이 있는데, 이러한 단점을 보완하기 위해 컴포넌트가 구현됐다


### 플러그인의 단점
- 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
- MySQL 서버의 변수나 함수를 직접 호출하기 떄문에 안전하지 않음(캡슐화 안 됨)
- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

---------------------------------------------------------------------------------------------------------------------------------------

> ## 쿼리 실행 구조

### 쿼리 실행 순서
1. SQL 요청
2. 쿼리 파서
3. 전처리기
4. 옵티마이저
5. 쿼리 실행기
6. 스토리지 엔진


### 쿼리 파서
- 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 트리 형태의 구조로 만들어 내는 작업
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 된다


### 전처리기
- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다
- 토큰을 테이블 이름이나 컬럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행
- 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다


### 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다


### 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다
- 예시
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김


### 핸들러(스토리지 엔진)
- 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할
- MyISAM 테이블을 조작하는 경우 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우 InnoDB 스토리지 엔진이 된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 복제

### 복제 Replication
- 복제의 관해서는 별도의 장에서 다루기로 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 쿼리 캐시

### 쿼리 캐시 Query Cache
- SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환했다
- 단점으로, 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제해야 했다 (성능 저하, 버그 유발)
- MySQL 8.0으로 올라오면서 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거됐다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 쓰레드 풀

### 개요
- 엔터프라이즈 에디션은 쓰레드 풀 기능을 제공하지만 커뮤니티 에디션은 쓰레드 풀 기능을 지원하지 않는다
- 책에서는 Percona Server에서 제공하는 쓰레드 풀 기능을 살펴본다


### Percona Server 쓰레드 풀
- 플러그인 형태로 작동하게 구현돼 있다
- 기본적으로 CPU 코어의 개수만큼 쓰레드 그룹을 생성한다
- 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다


### 쓰레드 풀
- 동시에 실행 중인 쓰레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능이다
- 스케쥴링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려질 수 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 트랜잭션 지원 메타데이터

### 메타데이터
- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 한다


### 데이터베이스, 테이블이 깨졌다
- MySQL 서버는 5.7 버전까지 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리했다
- 파일 기반의 메타데이터는 생성 및 변경 작업에 대해 트랜잭션을 지원하지 않기 때문에 비정상적인 오류가 발생되면 파일에 문제가 발생한다


### MySQL 메타데이터 변환
- MySQL 8.0 버전부터는 트랜잭션 문제 때문에 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 InnoDB의 테이블에 저장하도록 개선
- 시스템 테이블
  - 서버가 작동하는 데 기본적으로 필요한 테이블들을 묶어서 부르는 명칭
  - 예 : 사용자의 인증과 권한 테이블


### MySQL DB
- mySQL DB는 통째로 "mysql.ibd"라는 이름의 테이블스페이스에 저장


### ibd 파일
- "Oracle Corporation"에서 개발한 MySQL InnoDB Database Table


### CSV Comma Seperated Values
- 몇 가지 필드를 쉼포(,)로 구분하는 텍스트 데이터 및 텍스트 파일


### SDI Serialized Dictionary Information 파일
- InnoDB 이외의 테이블들에 대한 메타 정보를 저장하는 파일이다
- 기존의 *.FRM 파일과 동일한 역할을 한다
- InnoDB 테이블들의 구조도 SDI 파일로 변환할 수 있다 (ibd2sdi 유틸리티 사용)

---------------------------------------------------------------------------------------------------------------------------------------

> ## InnoDB 스토리지 엔진 아키텍처

### InnoDB 특징
- MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다


### 레코드
- 필드의 집합으로, 데이터로 다루어지는 단위, 처리의 기본 단위라 할 수 있다
- DB에서는 테이블에 행을 의미한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 프라이머리 키에 의한 클러스터링

### InnoDB 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다
- 프라이머리 키 값의 순서대로 디스크에 저장된다
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다
- 쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높게 된다
- 클러스터 키에 대해서는 8장에서 자세히 배움


### MyISAM
- 클러스터링 키를 지원하지 않는다
- MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 외래키 지원

### 외래키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다


### InnoDB 외래키
- 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하다
- 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크 작업이 필요하므로 잠금이 여러 테이블로 전파된다 (데드락 발생 조심)


### 외래키 설정
    //현재 세션에 설정
    SET (SESSION) foreign_key_checks=OFF;
    SET (SESSION) foreign_key_checks=ON;

    //GLOBAL 설정
    SET GLOBAL foreign_key_checks=OFF;
    SET GLOBAL foreign_key_checks=ON;

---------------------------------------------------------------------------------------------------------------------------------------

> ## MVCC

### 멀티 버전
- 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다


### MVCC Multi Version Concurrency Control
- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다
- 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라진다


### MVCC의 목적
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다


### InnoDB의 MVCC
- Undo log를 이용해 MVCC 기능을 구현한다


### MVCC 동작
- InnoDB 버퍼 풀
  - UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 새로운 값으로 업데이트 된다
- Undo log
  - UPDATE 문장이 실행되기 이전 데이터를 저장한다
  - 트랜잭션이 길어지면 언두 로그 영역에 데이터가 많아질 수 있다
  - 커밋, 롤백 되면 데이터가 삭제된다 (트랜잭션이 더는 없을 때 삭제)
- 데이터 파일(디스크)
  - InnoDb 버퍼 풀의 변경 내용은InnoDb 스토리지 엔진의 백그라운드 쓰레드에 의해서 기록된다
  - 그래서 InnoDb 버퍼 풀의 변경 내용이 디스크의 데이터 파일에 기록됐는지 여부는 시점에 따라 다를 수 있다
- SELECT 조회 쿼리 수행
  - UPDATE 작업 중인 레코드를 조회하면 시스템 변수 "transaction_isolation"에 설정된 격리 수준에 따라 조회 결과가 달라진다
  - 격리 수준 Isolation level
    - READ_UNCOMMITTED : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환 (변경된 상태 반환)
    - READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE : Undo log에 데이터를 읽어서 반환 (변경전 상태 반환)


### 잠금 없는 일관된 읽기 Non-Locking Consistent Read
- 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준인 경우 항상 잠금을 대기하지 않고 바로 실행


### 트랜잭션 성능 문제
- 언두 로그에 너무 많은 데이터가 쌓이면 성능에 문제가 발생할 수 있다
- 따라서, 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 자동 데드락 감지

### InnoDB
- 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다 (Wait-for List)
- 데드락 감지 쓰레드를 가지고 있어서 데드락 감지 쓰레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션이 있으면 강제 종료한다
  - 어느 트랜잭션을 먼저 강제 종료할 것인지를 판단하는 기준은 언두 로그 양이다
  - 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다


### 다른 엔진의 테이블 관리
- innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 + 테이블 레벨의 잠금까지 감지할 수 있다 (활성화 하자)


### 데드락 감지의 성능
- 동시 처리 쓰레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 쓰레드가 느려진다
- 데드락 감지 쓰레드는 잠금 목록을 검사해야 되기 때문에 잠금 목록 저장 리스트에 잠금을 걸고 데드락 쓰레드를 찾게 된다
- 데드락 감지 쓰레드가 느려지면 서비스 쿼리를 처리 중인 쓰레드는 더는 작업을 진행하지 못하고 대기하면서 느려진다
- 해결 방법
  - innodb_deadlock_detect 시스템 변수를 OFF로 설정하면 데드락 감지 쓰레드는 동작하지 않는다
  - 데드락 감지 쓰레드가 작동하지 않으면 데드락이 발생하는 상황에 무한정 대기하게 된다 (innodb_lock_wait_timeout 시스템 변수 설정)

---------------------------------------------------------------------------------------------------------------------------------------

> ## 자동화된 장애 복구

### 자동 복구
- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다
- 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write) 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다


### InnoDB 자동 복구
- InnoDB 스토리지 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다
- InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행한다
- 이 단계에서 자동으로 복구될 수 없는 손상이 있다면 자동 복구를 멈추고 MySQL 서버는 종료돼 버린다
  - innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 실행해야 한다


### innodb_force_recovery
- InnoDB의 로그 파일이 손상됐다면 6으로 설정하고 MySQL 서버를 기동한다
- InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 MySQL 서버를 기동한다
- 어떤 문제인지 알 수 없다면 1~6까지 변경하면서 재시작해 본다
- 숫자가 커질수록 심각한 상황이어서 데이터 손실 가능성이 커지고 복구 가능성은 적어진다
- 모든 숫자를 변경했는데 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다

---------------------------------------------------------------------------------------------------------------------------------------

> ## InnoDB 버퍼 풀

### 개요
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분이다
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다
- 버퍼 풀이 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀의 크기 설정

### 버퍼 풀의 크기 변화
- MySQL 5.7 버전부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선됐다
- 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 증가시키는 방법이 최적이다


### 버퍼 풀 크기 설정 팁
- 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정한다.
- 전체 메모리 공간이 그 이상이라면 InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올라가면서 최적점을 찾는다
- 운영체제의 전체 메모리 공간이 50GB 이상이라면, 대략 15GB에서 30GB 정도를 남겨두고 나머지를 InnoDB 버퍼 풀로 할당하자


### innodb_buffer_pool_size
- 버퍼 풀 사이즈를 변경할 수 있는 시스템 변수


### 참고
- 버퍼 풀의 변경은 크리티컬한 변경이므로 가능하면 서버가 한가한 시점을 골라서 진행하는 것이 좋다


### 버퍼 풀 개선
- InnoDB 버퍼 풀은 버퍼 풀 전체를 관리하는 잠금(세마포어)로 인해 내부 잠금 경합을 많이 유발했다
- 이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선됐다
- 여러 개의 작은 버퍼 풀로 쪼개지면서 잠금 자체도 경합이 분산되는 효과를 내게되는 것이다
- 각 버퍼 풀을 버퍼 풀 인스턴스라고 표현한다


### 버퍼 풀 인스턴스
- 전체 버퍼 풀을 위한 메모리 크기가 1GB 미만이면 버퍼 풀 인스턴스를 1개만 생성된다
- 버퍼 풀로 할당할 수 있는 메모리 공간이 40GB 이하 수준이라면 기본 값이 8을 유지한다
- 메모리가 크다면 인스턴스 개수를 설정하는 것이 좋다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀의 구조

### 버퍼 풀 자료 구조
- LRU Least Recently Used 리스트
  - 엄밀하게 말하면 LRU, MRU(Most Recently Used)가 결합된 형태이다
  - OLD 리스트는 LRU, New 리스트는 MRU를 사용한다 
- 플러시 리스트
- 프리 리스트
  - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
  - 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다


### InnoDB 데이터 찾는 과정
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
   - InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
   - 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
   - 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동 (대량 읽기의 경우 실제로 사용되지 않는 경우도 있음) 
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여된다
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가


### 플러시 리스트
- 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다
- 디스크에서 읽은 상태 그대로 전혀 변경이 없다면 플러시 리스트에 관리되지 않는다
- 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀과 리두 로그

### 버퍼 풀과 성능
- InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다
- 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이라면 성능에 도움이 되지 않는다
- InnoDB 버퍼 성능 향상 용도
    1. 데이터 캐시
    2. 쓰기 버퍼링


### 리두 로그 파일
- LSN Log sequence Number
  - 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 가진다
  - InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다
  - 이렇게 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다


### 활성 리두 공간
- 전체 리두 로그 파일에서 재사용이 불가능한 공간 


### 체크포인트 에이지
- 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이
- 즉, 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다


### 성능
- 버퍼 풀이 리두 로그에 비해 많이 큰 경우
  - 더티 페이지를 할당할 수 있는 공간이 너무 작아서 잦은 기록이 발생한다
- 버퍼 풀이 리두 로그에 비해 많이 작은 경우
  - 버퍼 풀에 더티 페이지의 비율이 높은 상태에서 버퍼 풀이 필요해지는 상황이 오면 많은 더티 페이지를 한 번에 기록해야 한다


### 성능 팁
- 처음부터 리두 로그 파일의 크기를 적절히 선택하기 어렵다면 버퍼 풀의 크기가 100GB 이하의 서버에서는 5~10GB 수준으로 선택하고 늘려가자


### 참고
- 리두 로그 공간이 버퍼 풀과 똑같을 필요는 없다
- 상대적으로 리두 로그 공간이 버퍼 풀에 비해 훨씬 작은 공간만 가지고 있어도 된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀 플러시

### 터티 페이지 플러시 변화
- MySQL 5.6 버전
  - InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽게 처리되지 않았다
  - 예를 들어, 급작스럽게 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 받는 경우가 많았다
- MySQL 5.7 이후
  - 대부분의 서비스에서 더티 페이지를 디스크에 동기화하는 부분에 오류가 수정되었다
  - 특별히 성능 문제가 발생하지 않는다면 시스템 변수를 조정할 필요가 없다 


### 플러시 백그라운드 기능
1. 플러시 리스트 플러시
2. LRU 리스트 플러시


### 플러시 리스트 플러시
- 플러시 리스트에서 플러시 함수를 호출해 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행
- 클리너 쓰레드 Cleaner Thread
  - InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 쓰레드
  - innodb_page_cleaners 설정값이 버퍼 풀 인스턴스 개수보다 많은 경우 하나의 클리너 쓰레드가 하나의 버퍼 풀 인스턴스를 처리하도록 자동으로 맞춘다
- 관련 시스템 변수
  - innodb_page_cleaners
  - innodb_max_dirty_pages_pct_lwm
  - innodb_max-dirty_pages_pct
  - innodb_io_capacity
  - innodb_io_capacity_max
  - innodb_flush_neighbors
  - innodb_adaptive_flushing
  - innodb_adaptive_flushing_lwm


### 더티 페이지
- 기본적으로 전체 버퍼 풀이 가진 페이지의 90%까지 더티 페이지를 가질 수 있다
  - innodb_max-dirty_pages_pct 시스템 설정 변수를 이용해 더티 페이지의 비율을 조정할 수 있다
- 디스크 쓰기 폭발 Disk IO Burst
  - InnoDB 스토리지 엔진은 innodb_io_capacity 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행한다
  - 디스크로 기록되는 더티 페이지 개수보다 더 많은 더티 페이지가 발생하면 버퍼 풀에 더티 페이지가 계속 증가하게 된다
  - 더티 페이지의 비율이 시스템 변수 설정을 넘어가게 되면 급작스럽게 디스크 쓰기가 폭증하는 현상이 발생한다
  - innodb_max_dirty_pages_pct_lwm 시스템 변수를 통해 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록한다


### innodb_io_capacity, innodb_io_capacity_max
- 각 데이터베이스 서버에서 어느 정도의 디스크를 읽고 쓰기가 가능한지 설정하는 값이다
- InnoDB 스토리지 엔진은 내부적ㅇ니 최적화 알고맂므을 가지고 있어서 설정된 값들을 기준으로 적당히 계산된 횟수만큼 더티 페이지 쓰기를 한다


### 어댑티브 플러시 Adaptive flush
- 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행한다
- innodb_adaptive_flushing_lwm 시스템 변수
  - 기본값 10% : 전체 리두 로그 공간에서 활성 리두 로그의 공간이 10% 미만이면 어댑티브 플러시가 작동하지 않는다


### LRU 리스트 플러시
- LRU 리스트에서 사용 빈도가 낮은 데이터 페이즈들을 제거해서 새로운 페이지들을 공간을 만드는데, 이를 위해 LRU 리스트 플러시 함수가 사용
- innodb_lru_scan_depth
  - 시스템 변수에 설정된 개수만큼 페이지들을 스캔한다
  - 스캔하면서 더티 페이지는 디스크에 동기화하고, 클린 페이지는 프리 리스트로 페이지를 옮긴다
- 실질적인 스캔
  - (innodb_buffer_pool_instances * innodb_lru_scan_depth) 수 

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀 상태 백업 및 복구

### 워밍업 Warming up
- 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태
- 버퍼 풀이 잘 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다


### 버퍼 풀 백업
- MySQL 5.5
  - MySQL 서버를 재시작하는 경우 서비스를 오픈하기 전에 강제 워밍업을 위해 주요 테이블과 인덱스에 대해 풀 스캔을 한 번씩 실행했다
- MySQL 5.6
  - 버퍼 풀 덤프 및 적재 기능이 도입
  - innodb_buffer_pool_dump_now
    - 현재 InnoDB 버퍼 풀의 상태를 백업

---------------------------------------------------------------------------------------------------------------------------------------

> ## 버퍼 풀의 적재 내용 확인

### 버퍼 풀 적재 내용 확인 문제
- information_schema 데이터베이스의 innodb_buffer_page 테이블을 이용해 InnoDB 버퍼 풀의 메모리의 적재를 확인할 수 있었다
- 그러나, InnoDB 버퍼 풀이 큰 경우에는 이 테이블 조회를 사용할 수 없었다
- MySQl 8.0 버전에서는 이런 문제점을 해결하기 위해 information_schema 데이터베이스에 innodb_cached_indexes 테이블이 추가되었다


### 인덱스 별로 적재 확인하기
    SELECT 
      * 
    FROM information_schema.innodb_tables it
    INNER JOIN information_schema.innodb_indexes ii ON ii.table_id = it.table_id
    INNER JOIN information_schema.innodb_cached_indexes ici ON ici.index_id = ii.index-id

    WHERE it.name=CONCAT('emplyees', '/', 'emplyees');

---------------------------------------------------------------------------------------------------------------------------------------

> ## Double Write Buffer

### 파셜 페이지(Partial-page) 톤 페이지(Torn-page)
- InnoDB의 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있다
- InnoDB 스토리지 엔진에서는 이 문제를 막기 위해 Double-Write 기법을 이용한다


### Double-Write 기법
- 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 묶어서 한 번의 디스크 쓰기로 DoubleWrite 버퍼에 기록한다
- DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다
- 데이터의 안정성을 위해 자주 사용되는데, HDD에서는 부담이 없지만, SDD에서는 부담스럽다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 언두 로그

### 언두 로그 기능 
- 트랜잭션 보장
  - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 한다
  - 언두 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구한다
- 격리 수준 보장
  - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환

---------------------------------------------------------------------------------------------------------------------------------------

> ## 언두 로그 모니터링

### UPDATE 쿼리 데이터 저장 과정
- UPDATE가 수행되면 디스크에 변경된 데이터를 저장하고, 언두 로그 영역에 이전 데이터를 저장한다
- 커밋하면 언두 로그에 이전 데이터를 삭제한다
- 롤백하면 언두 로그에 있는 이전 데이터를 다시 데이터 파일로 복구한다


### 트랜잭션 격리 수준
- 한 트랜잭션이 데이터를 변경할 때, 다른 트랜잭션에서 이 데이터를 어떻게 보여줄지 결정하는 것을 의미한다


### 언두 로그 공간
- MySQL 5.5 이전 버전의 MySQL 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다 (트랜잭션 완료하지 않은 경우)
- MySQL 8.0에서 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것도 가능해졌다
  - 때로는, MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄여 주기도 한다


### 참고
- MySQL 서버에서 INSERT,UPDATE 언두 로그는 따로 관리된다
- UPDATE, DELETE 문은 MVCC를 위해 사용된다
- INSERT 문은 MVCC를 위해서 사용되지 않고 롤백이나 데이터 복구만을 위해서 사용된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 언두 테이블스페이스 관리

### 언두 테이블스페이스
- 언두 로그가 저장되는 공간


### 언두 테이블스페이스 역사
- MySQL 5.6 이전
  - 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장됐다
- MySQL 8.0
  - 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선


### 언두 테이블스페이스 구조
- 언두 테이블스페이스
  - 1개 이상 128개 이하의 롤백 세그먼트를 가진다
- 롤백 세그먼트
  - 1개 이상의 언두 슬록을 가진다
  - InnoDB 페이지 크기를 16바이트로 나눈 값의 개수만큼의 언두 슬롯을 가진다 (페이지 16Kb면, 언두 슬롯은 1024개)


### 트랜잭션이 사용과 언두 슬롯
    최대 동시 트랜잭션 수 = (InnoDb 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)
- 하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 트랜잭션이 실행하는 INSERT, UPDATE, DELETE에 따라 최대 4개까지 사용한다
- 일반적으로는 트랜잭션이 임시 테이블을 사용하지 않으므로 하나의 트랜잭션은 대략 2개 정도의 언두 슬롯을 필요로 한다
- 언두 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다


### Undo tablespace truncate
- 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것
- 종류
  - 자동 방법
  - 수동 방법


### 언두 퍼지 Undo Purge
- InnoDB 스토리지 엔진의 퍼지 쓰레드는 주기적으로 깨어나서 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업을 실행한다
- 이 작업을 언두 퍼지라고 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 체인지 버퍼

### 인덱스
- 테이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다


### 체인지 버퍼 Change Buffer
- INSERT, UPDATE 쿼리 수행 시 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다
- 인덱스 페이지가 버퍼 풀에 존재하지 않으면 업데이트를 바로 수행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환한다
- 이때 사용하는 임시 메모리 공간을 체인지 버퍼라고 한다


### 주의사항
- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다


### 머지 쓰레드 merge thread
- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 쓰레드에 의해 병합된다


### 체인지 버퍼와 버퍼 풀
- 체인지 버퍼는 기본적으로 InnoDB 버퍼 풀로 설정된 메모리 공간의 25%까지 사용할 수 있게 설정돼 있다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 리두 로그 및 로그 버퍼

### ACID
- 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
- 성질
  - 원자성 Atomicity : 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력
  - 일관성 Consistency : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다
  - 독립성 Isolation : 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들이 못하도록 보장하는 것을 의미
  - 지속성 Durability : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함


### 리두 로그 Redo Log
- 오류로 인해 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다
- MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다
- 성능을 위해 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀, 로그 버퍼 등과 같은 자료 구조도 가지고 있다


### MySQL 서버 비정상 종류시 오류 데이터
1. 커밋됐지만 데이터 파일에 기록되지 않은 데이터
   - 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 된다
2. 롤백됐지만 데이터 파일에 이미 기록된 데이터
   - 언두 로그의 저장된 데이터를 데이터 파일에 복사하면 된다
   - 변경이 커밋됐는지, 롤백됐는지 등을 확인하기 위해 리두 로그가 필요하다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 리두 로그 아카이빙

### 개요
- MySQl 8.0 버전부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능이 추가됐다


### 리두 로그 아키이빙에 필요성
- MySQL 서버에 유입되는 데이터 변경이 너무 많으면 리두 로그가 매우 빠르게 증가하고, 리두 로그에 덮어쓰이는 문제가 발생할 수 있다
- 이러한 문제점을 해결하기 위해 리두 로그 아카이빙 기능이 MySQl 8.0에서 생겼다


### innodb_redo_log_archive_dirs
- MySQL 서버에서 아카이빙된 리두 로그가 저장될 디렉토리를 설정하는 시스템 변수
- 이 디렉터리는 운영체제의 MySQL 서버를 실행하는 유저(일반적으로 mysql 유저)만 접근이 가능해야 한다


### 리두 로그 아카이빙 시작
    DO innodb_redo_log_archive_start('backup', '20200722');
- 첫번째 파라미터 : 리두 로그를 아카이빙할 디렉터리에 대한 렝이블
- 두번째 파라미터 : 서브디렉터리의 이름


### 리두 로그 아카이빙 종료
    DO innodb_redo_log_archive_stop();
- 리두 로그 아카이빙을 시작한 세션이 끊어진다면 리두 로그 아카이빙을 멈추고 아카이빙 파일도 자동으로 삭제한다


### 리두 로그 아카이빙 시점
- 리두 로그 파일에 로그 엔트리가 추가될 때 기록된다


### UDF User Defined Function
- 사용자 정의 함수

---------------------------------------------------------------------------------------------------------------------------------------

> ## 리두 로그 활성화 및 비활성화

### 리두 로그 비활성화의 필요성
- 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화해서 데이터의 적재 시간을 단축시킬 수 있다
- 완료 후에 리두 로그를 다시 활성화하는 것을 잊지 말자


### 리두 로그 설정 변경
    // 리두 로그 비활성화
    ALTER INSTANCE DISABLE INNODB REDO_LOG;

    // 리두 로그 호라성화
    ALTER INSTANCE ENABLE INNODB REDO_LOG;

---------------------------------------------------------------------------------------------------------------------------------------

> ## 어댑티브 해시 인덱스

### 어댑티브 해시 인덱스
- InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- innodb_adaptive_hash_index 시스템 변수를 통해 제어할 수 있다


### 어댑티브 해시 인덱스의 필요성
- B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다


### 어댑티브 해시 인덱스 
- 키 값 : B-Tree 인덱스의 고유번호(ID)와 B-Tree 인덱스의 실제 키 값의 조합으로 생성된다
- 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다


### 어댑티브 해시 인덱스가 도움이 되지 않는 경우
1. 디스크 읽기가 많은 경우
2. 특정 패턴의 쿼리가 많은 경우(조인이나 LIKE 패턴 검색)
3. 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우


### 어댑티브 해시 인덱스가 도움이 되는 경우
1. 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
2. 동등 조검 검색(동등 비교와 IN 연산자)이 많은 경우
3. 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

---------------------------------------------------------------------------------------------------------------------------------------

> ## InnoDB와 MyISAM, MOMORY 스토리지 엔진 비교

### InnoDB, MyISAM
- 이전에는 MyISAM에 시스템 테이블이 많이 존재했다
- MySQL 8.0부터 모든 기능이 InnoDB로 이동됐다 (MyISAM 기능이 적어지면서 없어질 것으로 예상)


### MEMORY 스토리지 엔진 
- 동시 처리 성능에 있어서 InnoDB 스토리지 엔진보다 성능이 떨어진다 (테이블 수준의 잠금 처리)
- 단일 쓰레드에서는 InnoDB보다 빠를 수 있다
- 이전에는 임시 테이블의 용도로 사용됐지만, 지금은 TempTable 스토리지 엔진에 임시 테이블을 만들어서 사용한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## MyISAM 스토리지 엔진

### 키 캐시 Key Cache
- InnoDB의 버퍼 풀과 비슷한 역할을 한다
- 인덱스만을 대상으로 작동한다
- 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다


### 키 캐시 히트율
    키 캐시 히트율 = 100 - (Key-reads / Key_read_requests * 100)


### 운영체제의 캐시 및 버퍼
- MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다
- MyISAM 테이블의 데이터에 대해서는 디스크로부터의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 없다


### 데이터 파일과 프라이머리 키(인덱스) 구조
- MyISAM 테이블은 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용된다
- MyISAM 테이블에 레코드는 프라이머리 키 값과 무관하게 INSERT 되는 순서대로 데이터 파일에 저장된다
- 프라이머리 키와 세컨더리 인덱스는 모두 데이터 파일에 저장된 레코드의 ROWID 값을 포인터로 가진다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 에러 로그 파일

### 에러 로그 파일
- MySQL 서버가 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다
- 파일 경로
  - MySQL 설정 파일(my.cnf)에서 "log_error"라는 이름의 파라미터로 정의된 경로에 생성된다
  - 따로 설정하지 않는 경우 데이터 디렉터리에 ".err"라는 확장자가 붙은 파일로 생성된다


### MySQL 시작과 관련된 정보성 및 에러 메시지
- MySQL 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우에는 반드시 에러 로그 파일을 통해 확인해야 한다


### InnoDB의 트랜잭션 복구 메시지
- InnoDB의 경우 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 하게 된다
- 이 과정에 대한 간단한 메시지가 출력된다


### 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 쿼리의 실행 도중 발생한 에러나 복제에서 문제가 될 만ㅁ한 쿼리에 대한 경고 메시지가 에러 로그에 기록된다


### 비정상적으로 종료된 커넥션 메시지 Aborted connection
- 클라이언트의 connection이 비정상적으로 종료되는 경우 메시지를 기록한다
- 이런 메시지가 많이 기록된다면 어플리케이션의 커넥션 종료 로직을 한번 검토해볼 필요가 있다


### InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
- InnoDB 모니터링 활성화 상태로 만들어 두고 그대로 유지하는 경우에는 에러 로그 파일이 매우 커져서 문제가 발생할 수 있다


### MySQL의 종료 메시지
    // 사용자에 의한 종료
    Received SHUTDOWN from user

---------------------------------------------------------------------------------------------------------------------------------------

> ## 제너럴 쿼리 로그 파일 General log

### 제너럴 쿼리 로그 파일
- 시간 단위로 실행됐던 쿼리의 내용이 모두 기록된다
- MySQL 서버가 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 슬로우 쿼리 로그

### 슬로우 쿼리 로그
- long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다
- 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에 기록될 수 있다





