
 테스트.
 145 ~ 207page.



 # Test 다시보기.

테스트.
테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서,
만든 코드를 확신할 수 있게 해주는 작업.

웹을 통한 DAO 테스트 방법의 문제점.
오류가 어디서 발생했는지 너무 많은 코드를 확인해봐야한다.

작은 단위의 테스트.
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡하고, 정확한 원인을 찾기 힘들다.
이러한 테스트 방식을 "단위 테스트 Unit test" 라고 한다.

단위테스트 unit test.
단위의 크기와 범위는 딱 정해진 건 아니고, 일반적으로 단위는 작을수록 좋다.
단위테스트가 끝나면 전 과정을 하나로 묶어서 테스트할 필요가 있다.

자동수행 테스트 코드.
main( )처럼 별다른 호출없이 자동으로 실행할 수 있는 테스트가 필요하다.
자동수행 테스트의 장점은 자주 반복할 수 있다는 것이다.



 # Test 개선.

테스트 검증의 자동화.
테스트를 실행하고 테스트에 실행 결과를 성공 실패로 나누어 보여준다.
테스트 에러 : 테스트 실패 중 에러가 발생한 경우 
테스트 실패 : 테스트 실패 중 기대한 결과 값과 다른 경우로 나눌 수 있다.

테스트 메소드 원칙.
1. 메소드에 @Test 어노테이션을 붙인다.
2. public으로 만든다.
3. void로 만든다.

검증 코드.
JUnit에 static 메소드 assertThat( a, is( b ) )를 활용한다.
a는 값, b는 macher로 조건이 다르면 테스트 실패로 처리한다.
is( b )는 eauls( )와 비슷한 종류로 비교해주는 기능을 가졌다.

JUnit 테스트 실행.
JUnitCore.main( "패키지.테스트클래스" ) ;
테스트 성공시 - OK , 실패시 - failures.



 # 개발자를 위한 테스팅 프레임워크 JUnit.

IDE를 통한 JUnit 테스트 실행 방법.
Run As 항목에서 JUnit Test를 선택.
JUnitCore.main( )을 만들지 않아도 된다.
@Test가 붙은 테스트 메소드의 이름을 모두 보여준다.

빌드 툴을 활용한 JUnit 테스트 실행 방법.
테스트 실행 결과가 HTML이나 텍스트 파일로 만들어진다.
여러 개발자와 협업시 테스트 결과를 메일로 보낼 때 사용한다.
대부분 IDE를 통한 JUnit을 활용한다.

자동 테스트의 주의사항.
테스트 로직을 실행하기 전에 DB에 있는 데이터들을 지워준다.
똑같은 작업을 반복해서 test해도 성공할 수 있도록 만들어야된다.

JUnit 테스트 주의사항.
테스트 메소드의 실행 순서를 보장해주지 않는다.

@Test 예외.
@Test expected에 발생될만한 Exception을 기재한다.
예외가 발생해야 테스트가 성공이다.
예시 - @Test( expected=Exception.clss )

포괄적인 테스트.
테스트를 작성할때는 다양한 상황과 입력 값을 고려해야된다.
네거티브 테스트를 먼저 만들어라.

기능설계를 위한 테스트.
테스트 코드가 조건, 행위, 결과로 작성되어 기능정의서 역할을 할 수 있다.
테스트가 실패하면 설계한 대로 코드가 만들어지지 않았음을 알 수 있다.

테스트 주도 개발 TDD Test Driven Development.
"테스트 우선 개발 Test First Development" 라고도 한다.
테스트 코드를 먼저 만들고, 테스트를 성공하는 코드를 작성하는 방식.
실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
TDD를 하면 자연스럽게 단위 테스트를 할 수 있다.

JUnit 실행 순서.
1. 테스트 클래스에서 @Test가 붙은 public, void, 파라미터가 없는 메소드를 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

JUnit 테스트 클래스.
각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해 
같은 클래스여도 @Test 메소드마다 새로운 테스트 클래스를 생성하여 실행한다.

픽스처 fixture.
테스트를 수행하는 데 필요한 정보나 오브젝트를 의미한다.
중복된 픽스처는 @Before에서 생성해서 관리해 주는 방법도 있다.



 # 스프링 테스트 적용.

@BeforeClass.
테스트 클래스 전체에 걸쳐 딱 한번만 실행하는 JUnit에서 제공하는 스태틱 메소드.

@RunWith.
스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능을 지정한다.
@ReunsWith( SpringJUnit4ClassRunner.class )

@ContextConfiguration.
자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정.
@ContextConfiguration( locations= "/경로/context설정파일이름" ) ;

테스트 클래스의 컨텍스트 공유.
모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용하면 클래스끼리도 공유가능.
성능 향상에 큰 도움이된다.

@Autowired.
변수 타입과 일치하는 클래스가 애플리케이션 컨텍스트안에 bean으로 존재하면 자동으로 연결해준다.
application context는 초기화할 때 자기 자신도 빈으로 등록한다.

인터페이스에 DI하는 이유.
1. 구현 클래스가 바뀔 수 있기 때문에.
2. 다른 차원의 서비스 기능을 도입할 수 있기 때문.
3. 테스트를 쉽게 하기 위해서. ( 가능한 작은 단위의 대상에 테스트 )

Test용 DI 설정.
1. DirtiesContext.
2. Test용 application context xml파일을 하나 더 만든다.

@DirtiesContext.
이 어노테이션이 붙은 테스트 클래스는 애플리케이션 컨텍스트을 공유하지 않는다.
메소드에서도 사용가능.

Test용 context 생성.
@RunWish( SpringJUnit4ClassRunner.class )
@ContextConfiguration( locations="/경로/testcontext.xml이름" )

컨테이너 없이 테스트의 특징.
수행 속도가 가장 빠르고 테스트 자체가 간결하다.



 # 학습 테스트로 배우는 스프링.

학습 테스트 learning test.
자신이 만들지 않은 프레임워크나 라이브러리에 대해 테스트를 작성하는 것.

학습 테스트의 장점.
다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
학습 테스트 코드를 개발 중에 참고할 수 있다.
프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
테스트 작성에 대한 좋은 훈련이 된다.
새로운 기술을 공부하는 과정이 즐거워진다.

버그 테스트 bug test.
오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트.
버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것.

버그 테스트의 장점.
테스트의 완성도를 높여준다.
버그의 내용을 명확하게 분석하게 해준다.
기술적인 문제를 해결하는 데 도움이 된다.

동등분할 equivalence partitioning.
같은 결과를 내는 범위를 구분해서 각 대표 값으로 테스트 하는 방법.

경계값 분석 boundary value analysis.
동등분할 범위의 경계에서 에러가 많이 발생한다는 특징을 이용해서 경계 근처를 테스트.




