
 템플릿(1)
 209 ~ 231page

 

 # 다시 보는 초난감 DAO.

개방 폐쇄 원칙 OCP Open Closed Principle.
어떤 부분은 변경을 통해 기능을 확장하고, 어떤 부분은 고정되어 변하지 않는 것.

리소스 반환과 close( ).
리소스를 반환할때 close( )라는 메소드를 사용한다.
Connection과 statement는 풀로 관리되어 객체를 호출하면 풀에 생성된 것을 사용한다.
close( )를 안해주면 풀에 미리 만들어진 객체가 없어서 오류가 발생한다.



 # 변하는 것과 변하지 않는 것.

메소드 추출.
변하지 않는 부분은 그대로 두고, 변하는 부분을 메소드로 따로 분리한다.

템플릿 메소드 패턴의 적용.
상속을 통해 기능을 확장해서 사용하는 것을 의미한다.
변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 서브클래스에서 오버라이드한다.
상속 관계를 사용하기 때문에 유연성이 떨어진다. ( 의존도가 높다 )

전략 패턴의 적용.
변하는 부분을 인터페이스로 만들어서 구현 클래스에서 기능을 오버라이드한다.
변하지 않는 부분을 가진 클래스에서 인터페이스를 호출하고 필요한 구현 클래스를 주입한다.

마이크로 DI.
DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 DI를 적용한 경우.
코드에 의한 DI라는 의미로 수동 DI라고도 불린다.



 # JDBC 전략 패턴의 최적화.

중첩클래스 nested class.
다른 클래스 내부에 정의되는 클래스.

중첩 클래스의 종류.
스태틱 클래스 static class : 독립적으로 오브젝트로 만들어질 수 있는 클래스.
내부 클래스 inner class : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 클래스.
멤버-내부 클래스 : 오브젝트 레벨에 정의되는 내부 클래스.
로컬 클래스 : 메소드 레벨에 정의되는 내부 클래스.
익명-내부 클래스 : 이름을 갖지 않는 내부 클래스.

내부 클래스 주의사항.
내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해야된다.

재사용 할 경우 익명 내부 클래스.
인터페이스 변수이름 = new 인터페이스이름( ) { 실행할 코드 ; } ;

자사용 하지 않을 경우 익명 내부 클래스.
메소드이름( new 인터페이스이름( ) { 실행할 코드 ; } ) ;

로컬 클래스의 외부 변수 사용.
로컬 클래스를 선언한 메소드에 final이 붙은 변수를 로컬 클래스에서 사용하면 지역변수,
final이 없는 변수를 로컬 클래스에서 사용하면 인스턴스 변수로 복사된다.
원리 : 메소드의 변수들은 메소드 실행 후 사라지지만 로컬 클래스는 사라지지 않아서 복사 후 사용.






