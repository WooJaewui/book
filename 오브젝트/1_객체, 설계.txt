
 객체 설계.



 #  로버트 L. 글래스.

이론 vs 실무.
- 실무가 먼저 발전되고, 실무에 대한 경험이 많이 쌓였을 때 이론이 발전한다.
- 해당 분야가 충분히 성숙해진 후에 이론이 실무를 역전한다.
- 추상적인 개념과 이론은 훌륭한 코드를 작성하는 데 필요한 도구일 뿐이다.



 # 티켓판매 애플리케이션 구현하기.

클래스.
1. 티켓 - fee 가격.
2. 티켓 판매소 - 티켓개수, 돈
3. 티켓 판매원 - 티켓 판매소
4. 가방 - 돈, 티켓, 이벤트 교환권.
5. 관객 - 가방.
6. 방문 - 시간.
7. 극장 - 티켓 판매원.


 # 무엇이 문제인가.

모듈.
- 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소.

소프트웨어 모듈의 3가지 목적.
1. 실행 중에 제대로 동작한다.
2. 변경을 위해 존재한다.
	- 간단한 작업만으로 변경이 가능해야 한다.
3. 코드를 읽는 사람과 의사소통해야 한다.

위에 작성한 코드의 문제점.
1. 한 클래스에서 너무 많은 일을 하고 있다.
2. 클래스들끼리의 결합도가 높아서 하나의 클래스를 변경하면 의존되어 있는 여러 클래스를 변경해야 된다.

의존성 dependency.
- 변경에 대한 영향을 암시한다.
- 어떤 객체가 변경될 때 그 객체에게 의존하는 다랜 객체도 함께 변경될 수 있다.

결합도 coupling.
- 객체 사이의 의존성이 과한 경우를 결합도가 높다고 말한다.
- 결합도가 높을 수록 변경하기 어려워진다.
- 의존성을 제거함으로써 결합도를 낮추자.

결합도.
- 모듈과 모듈간의 상호 의존 정도.
- 결합도를 낮춰야 확장성을 높일 수 있다.

응집도.
- 모듈 내부의 기능적인 집중 정도.
- 응집도가 높다는 것은 자기 클래스에서 자신의 데이터를 스스로 처리하는 것을 의미한다.



 # 설계 개선하기.

캡슐화 encapsulation.
- 객체 내부의 세부적인 사항을 감추는 것.

변경하기.
- 소극장에서 모든 기능을 처리했었는데, 관객은 관객의 일을하고, 티켓 판매자는 티켓 판매자의 일을 하게 만들자.
- 관객이 티켓을 구매할 때 가방을 검사해야 됐다.

변경 후.
- 소극장 클래스에서 판매자 클래스만 사용하고, 판매소 클래스는 사용하지 않는다. ( 판매소가 있는지 조차 확인할 수 없다 )
- 관객의 가방을 내부적으로 관객이 확인하도록 만든다.

절차지향 프로그래밍.
- 프로세스와 데이터를 별도의 모듈에 위치시키는 방식이다.

객체지향 프로그래밍.
- 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 이동시키는 것.
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식.

트레이드 오프 trade off.
1. 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 설계는 트레이드 오프의 산물이다.
	=> 모두 만족할 수 있는 방법은 없다.

의인화 anthropomorphism.
- 수동적인 무생물체 이더라도 객체지향의 세계에 들어오면 모든 것이 능동적이고 자율적인 존재로 바뀐다.



 # 객체지향 설계.

설계.
- 설계란 코드를 배치하는 것이다.

좋은 설계.
1. 기능을 구현하는 코드를 짠다.
2. 유지 보수를 쉽게 할 수 있어야 한다.

유지 보수.
- 코드를 수정하지 않으면 버그는 발생하지 않는다.
- 버그의 가장 큰 문제점은 코드를 수정하려는 의지를 꺾는다는 것이다.



















