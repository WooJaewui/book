
# 다형성.

-------------------------------------------------------------------------------------------------------------

> ## 다형성.

### 다형성 Polymorphism.
- '많은 형태를 가질 수 있는 능력'을 의미한다.
- 많음을 의미하는 'poly' 와 형태를 의미하는 'morph' 의 합성어이다. 

### 객체지향 프로그래밍에서 사용되는 다형성.
1. 유니버설 다형성 Universal.
   - 매개변수 Parametric : 변수의 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입을 지정하는 방식. (제네릭)
   - 포함 Inclusion : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력. (서브타입 다형성)
2. 임시 다형성 Ad Hoc.
   - 오버로딩 Overloading : 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우.
   - 강제 Coercion : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 연산자를 다양한 타입에 사용하는 방식.

-------------------------------------------------------------------------------------------------------------

> ## 상속의 양면성.

### 객체지향 패러다임의 근간.
- 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것.
- 따라서 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야 한다.

### 상속의 메커니즘을 이해하는 데 필요한 개념.
- 업캐스팅.
- 동적 메서드 탐색.
- 동적 바인딩.
- self 참조.
- super 참조.

### 메서드 오버라이딩.
- 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 새로운 구현으로 대체하는 것을 의미한다.

### 메서드 오버로딩.
- 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것을 의미한다.
- 자식 클래스 내부에서 만든 메서드끼리도 메서드 오버로딩은 가능하다.

### 데이터 관점에서 상속.
- 자식 인스턴스에서 부모 인스턴스로 접근 가능한 링크가 존재하는 그림 12-4처럼 생각해도 무방하다. (내가 이해한 방식)
- 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 된다.

### 행동 관점에서 상속.
- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.
- 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
- 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.

-------------------------------------------------------------------------------------------------------------

>## 업캐스팅과 동적 바인딩.

### 업캐스팅.
- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것을 의미한다.
- 서로 다른 클래스의 인스턴스를 동일한 타입에 할당하는 것을 가능하게 해준다.
- 부모 클래스에 대해 작성된 코드를 전혀 수정하지 않고도 자식 클래스에 적용할 수 있다.

### 동적 바인딩.
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.
- 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하는데, 이를 동적 바인딩이라고 한다.

### 동적 메서드 탐색.
- 부모 클래의 타입에 대해 메시지를 전송하더라도 실행 시에는 실제 클래스를 기반으로 실행될 메서드가 선택되게 해준다.

### 개방 폐쇄 원칙.
- 업캐스팅과 동적 메서드 탐색은 개방-폐쇄 원칙의 의도와 일치한다.
- 개방-폐쇄 원칙의 중심에는 추상화가 위치하고 있다.

### 업캐스팅 활용.
- 자식 클래스가 부모 클래스를 대체할 수 있게 허용한다. 
  1. 대입문.
  2. 메서드의 파라미터 타입.

### 다운캐스팅 down casting.
- 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해 명시적인 타입 캐스팅을 하는 것.
- 항상 가능하지 않고 제한적으로 가능하다.

### 함수 호출과 메서드 호출.
- 함수를 호출하는 전통적인 언어들은 호출될 함수를 컴파일타임에 결정한다. (정적 바인딩, 초기 바인딩, 컴파일타임 바인딩)
- 객체지향 언어에서 메서드는 메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다. (동적 바인딩, 지연 바인딩)

-------------------------------------------------------------------------------------------------------------

> ## 동적 메서드 탐색과 다형성.

### 실행할 메서드 선택.
1. 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사한다. 존재하면 메서드 실행 후 탐색 종료.
2. 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.
3. 상속 계층의 최상위 클래스에서도 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.

### self와 this.
- 동적 메서드 탐색은 'self' 가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄진다.
- 메서드 탐색이 종료되는 순간 self 참조는 자동으로 소멸된다.
- C++, 자바, C#에서는 self 참조를 'this' 라고 부른다.

### 동적 메서드 탐색의 원리.
1. 자동적인 메시지 위임.
   - 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 부모 클래스에게 처리를 위임한다.
2. 동적인 문맥 사용.
   - 메시지를 수신했을 때 어떤 메서드를 실행할지 결정하는 것은 실행 시점에 이뤄지며, 메서드를 탐색 하는 경로는 self 참조를 사용.

### 자동적인 메시지 위임.
- 적절한 메서드를 찾을 떄까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.
- 상속을 이용할 경우 메시지 위임과 관련된 코드를 명시적으로 작성할 필요가 없다.

### 메서드 오버라이딩.
- 자식 클래스가 부모 클래스에 존재하는 메서드와 동일한 시그니처를 가진 메서드를 정의해서 부모 메서드를 감추는 현상.
- 시그니처가 다른 경우 오버라이딩이 아니다.

### 메서드 오버로딩.
- 동일한 이름의 메서드지만, 시그니처가 다른 것을 의미한다.
- 클라이언트 관점에서 오버로딩된 모든 메서드를 호출할 수 있다.
- 일부 언어에서는 상속 계층 사이의 메서드 오버로딩을 지원하지 않는다. (대표적으로 C++)
- C++에서는 자식 클래스에서 오버로딩하면 모든 부모 클래스의 메서드를 감춰버린다.

### 동적 메서드 탐색 규칙.
- 언어마다 규칙이 다를 수 있다.
- 내가 사용하는 언어의 문법과 메서드 탐색 규칙을 주의깊게 살펴보자.

### self 전송.
- 부모 타입에서 this.메서드(), super.메서드()가 아닌 메서드()를 사용하면, self 에서부터 메서드를 다시 탐색하기 시작한다.

### 이해할 수 없는 메시지.
- 정적 타입.
  - 코드를 컴파일할 때 상속 계층 안의 클래스들이 메시지를 이해할 수 있는지 여부를 판단한다.
  - 상속 계층 탐색 후에 메시지를 처리할 수 있는 메서드가 없는 경우 컴파일 에러를 발생시킨다.
- 동적 타입.
  - 동적 타입 언어에는 컴파일 단계가 존재하지 않기 때문에 실제로 코드를 실행해보기 전에는 메시지 처리 가능 여부를 판단할 수 없다.
  - 실행할 메시지를 탐색하지 못했을 경우 런타임 에러가 발생한다.
  - 실행할 메시지를 탐색하지 못했을 때 에러를 발생하지 않고, 메시지를 전달하도록 만들 수 있다.

### super 참조.
- 자식 클래스에서 부모 클래스의 구현을 재사용해야 하는 경우 사용한다.
- super.메서드()는 부모 클래스의 메서드()를 호출하는 것이 아닌 부모에서부터 메서드()를 탐색하는 것이다.
- super 참조를 통해 메시지를 전송하는 것을 super 전송이라고 부른다.

-------------------------------------------------------------------------------------------------------------

> ## 상속 대 위임.

### 위임 delegation.
- 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것.
- 본질적으로는 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드의 탐색 과정을 다른 객체로 이동시키기 위해 사용한다.
- 위임은 항상 현재의 실행 문맥을 가리키는 self 참조를 인자로 전달한다.

### 포워딩.
- 최초의 객체에 다시 메시지를 전송할 필요는 없고 단순히 코드를 재사용하고 싶은 경우에 사용.
- 처리를 요청할 때 self 참조를 전달하지 않는 경우를 의미한다.

### 프로토타입 기반 프로그래밍.
- 객체지향 프로그래밍의 한 형태의 갈래로 클래스가 없고, 클래스 기반 언어에서 상속을 사용하는 것과 다르게, 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의
  동작 방식을 다시 사용할 수 있다.

### 프로토타입 기반 프로그래밍 - 자바스크립트.

        // Lecture 정의.
        function Lecture(name, scores) {
            this.name = name;
            this.scores = scores;
        }
        
        Lecture.prototype.stats = function() {
            return "Name : " + this.name + ", Evaluation Method : " ... ;
        }

        Lecture.prototype.getEvaluationMethod = funcion() {
            return "Pass or Fail";
        }

        // GradeLecture 정의.
        function GradeLecture(name, canceled, scores) {
            Lecture.call(this, name, scores);
            this.canceled = canceled;
        }

        GradeLecture.prototype = new Lecture();
        GradeLecture.protitype.constructor = GradeLecture;
        
        GradeLecture.prototype.getEvaluationMethod = function() {
            return "Grade";
        }
- GradeLecture의 prototype 에 Lecture의 인스턴스를 할당했기 때문에 Lecture 멤버에 접근할 수 있다.
- 메서드를 탐색하는 과정은 클래스 기반 언어의 상속과 거의 동일하다.
- 동적동적인 객체 사이의 위임을 통해 상속을 구현할 수 있다.

### 정리.
- 일반적으로 많은 객체지향 언어들이 클래스에 기반해서 다형성을 사용한다.
- 프로토타입처럼 객체 수준에서(동적으로) 상속을 구현하는 언어들도 존재한다.
- 클래스 기반 상속과 객체 기반의 위임 사이에 기본 개념과 메커니즘은 비슷하다.












