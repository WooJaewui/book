# 오브젝트 2장 객체지향 프로그래밍

--------------------------------------------------------------

> ## 영화 예매 시스템

### 요구사항.
- ### 영화.
  - 영화에 대한 기본 정보.
  - 제목, 상영시간, 가격 정보와 같이 영화가 가지고 있는 기본적인 정보를 저장. 
- ### 상영.
    - 실제로 관객들이 영화를 관라하는 사건을 의미. (영화 예매 대상)
    - 상영 일자, 시간, 순번 등을 가르키기 위해 사용.
- ### 할인 조건 discount condition.
    - 순서 조건과 기간 조건 두 종류로 나눌 수 있다.
    - 순서 조건은 상영 순번을 이용해 할인 여부를 결정하는 규칙.
    - 기간 조건은 영화 상영 시작 시간을 이용해 할인 여부를 결정. (요일,시작 시간, 종료 시간)
    - 영화별로 여러 개의 할인 조건을 설정할 수 있다.
- ### 할인 정책 discount policy.
    - 금액 할인 정책과 비율 할인 정책이 있다.
    - 금액 할인 정책은 일정 금액을 할인해주는 방식.
    - 비율 할인 정책은 일정 비율의 요금을 할인해 주는 방식.
    - 영화별로 하나의 할인 정책만 설정할 수 있다. (지정하지 않을 수도 있다)

---------------------------------------------------------------------------------

> ## 객체지향 프로그래밍을 향해

### 진정한 객체지향 패더라임으로의 전환.
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
    - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.
    - 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
    - 객체는 다른 객체에게 도움을 주거나 의존하면서 살아가는 협력적인 존재다.
    - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
    - 훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다.

### 도메인의 구조를 따르는 프로그램 구조

- ### 용어 정리.
  - 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야.

### 자율적인 객체.

- ### 객체의 특징.
  1. 객체는 상태와 행동을 함께 가지는 복합적인 존재이다.
  2. 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
    <br> **@@ 두 가지 특징은 서로 깊이 연관돼 있다. @@**
- ### 캡슐화.
    - 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것에서 한 걸음 더 나아가 접근 제어 매커니즘을 제공한다.
    - 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
    - 객체가 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.
    - 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알아서는 안 되며, 결정에 직접적으로 
      <br>개입하려고 해서도 안 된다.
- ### 캡슐화와 접근 제어.
    1. 퍼블릭 인터페이스 public interface.
       - 외부에서 접근 가능한 부분.
    2. 구현 implementation.
       - 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분.
         <br> **@@ 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다. @@** 
- ### 인터페이스와 구현의 분리 separation of interface and implementation.
  - 훌륭한 객체는 구현을 몰라도 인터페이스만 알면 쉽게 상호작용할 수 있다.
  - 이를 위해서는 구현을 공용 인터페이스 뒤에 철저하게 숨겨놓아야 하는데, 이를 인터페이스와 구현의 분리라고 부른다.
  - 객체 설계의 핵심은 객체를 외부와 내부로 분리해 설계하는 것이다.
  - 이 원칙이 중요한 이유는 소프트에어는 항상 변경되기 때문이다.
    - 수많은 객체들이 상호작용하며 작동하는 객체지향 공동체에서 객체를 수정했을 때 어떤 객체가 영향을 받을지 
      <br> 판단하는 것은 거의 불가능하다.
    - 미래에 변경이 가능한 부분은 객체의 내부에 감춰놓아야 한다.
    - 송신자와 수신자가 구체적인 구현 부분이 아니라 느슨한 인터페이스에 대해서만 결합되도록 만드는 방법이다.
    - 이 목적을 달성하기 위한 설계 방법을 캡슐화라고 한다.

### 프로그래머의 자유.

- ### 프로그래머의 역할.
    1. 클래스 작성자 class creator.
       - 새로운 데이터 타입을 프로그램에 추가한다.
    2. 클라이언트 프로그래머 client programmer.
       - 클래스 작성자가 추가한 데이터 타입을 사용한다. 
       - 필요한 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축하는 것.
  
- ### 구현 은닉 implementation hiding.
    - 클라이언트 프로그래머가 숨겨 놓은 부분에 접근할 수 없도록 방지함으로써 내부 구현을 마음대로 변경하는 것을 의미한다.
    - 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
    - 클라이언트 프로그래머는 내부의 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있다.

------------------------------------------------------------------------

> ## 상속과 다형성.

### 컴파일 시간 의존성과 실행 시간 의존성.

- ### 컴파일 시간 의존성과 실행 시간 의존성의 차이.
    - 코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.
    - 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
    - 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.
- ### 유연한 프로그램의 트레이드 오프.
    - 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 어려워진다.
    - 유연성을 억제하면 재사용성과 확장 가능성은 낮아진다.

### 차이에 의한 프로그래밍.

- ### 상속.
    - 상속은 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
    - 상속을 이용하여 클래스 사이에 관계를 설정하면 기존 클래스의 기능을 새로운 클래스에 포함시킬 수 있다.
- ### 차이에 의한 프로그래밍 programming by difference. 
    - 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법.

### 상속과 인터페이스.

- ### 인터페이스.
  - 인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다.
  - 상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.
  - 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다. (모든 인터페이스 포함)
- ### 업캐스팅 upcasting.
  - 자식 클래스가 부모 클래스를 대신하는 것을 의미한다.

### 다형성.

- ### 메시지와 메서드 차이.
  - 메시지 : 외부 객체에서 호출되는 의존된 객체의 인터페이스. (컴파일 의존 인터페이스)
  - 메서드 : 인터페이스를 오버라이드한 실제 실행되는 메서드. (런타임 의존 인터페이스)
- ### 다형성.
  - 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
  - 다형성은 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
  - 다형성은 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
- ### 메시지 메서드 바인딩 방식.
  - 지연 바인딩 lazy binding(동적 바인딩)
    - 메서지와 메서드를 실행 시점에 바인딩하는 것을 의미한다.
  - 초기 바인딩 early binding(정적 바인딩)
    - 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 의미한다.
- ### 상속의 분류.
  - 구현 상속 implementation inheritance.
    - 서브클래싱이라고 불린다.
    - 순수하게 코드를 재사용하기 위한 목적으로 사용하는 것을 의미한다.
    - 변경에 취약한 코드를 낳게 될 확률이 높다.
  - 인터페이스 상속 interface inheritance.
    - 서브타이핑이라고 불린다.
    - 다형적인 협력을 위해 부모 / 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것.

### 인터페이스와 다형성.

- ### 추상 클래스.
  - 내부 구현을 공유해야 될 때 사용한다.
  - 내부 구현을 공유하지 않아도 되면 인터페이스를 사용할 수 있다.
- ### 인터페이스.
  - C#과 자바에서 사용하는 프로그래밍 요소이다.

---------------------------------------------------------------------------------

> ## 추상화와 유연성.

### 추상화의 힘.

- ### 추상화의 장점.
  1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
     - 추상화를 통해 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
     - 자식 클래스들은 추상화를 이용해서 정의한 상위의 협력 흐름을 그대로 따르게 된다.
     - 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 활용한다.
  2. 추상화를 이용하면 설계가 좀 더 유연해진다는 것이다.
     - 추상화를 이용해 상위 정책을 표현하면 기존 구조를 수정하지 않고도 기능을 쉽게 확장할 수 있다.

### 유연한 설계.

- ### 협력 방식.
  - 책임의 일관성을 유지할 수 있는 방법으로 코딩하자.
  - 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라.
- ### 컨텍스트 독립성 context independency.
  - 인터페이스와 의존했을 때 인터페이스를 구현한 어떤 클래스와도 협력이 가능한 것을 의미한다.
  - 유연성이 필요한 곳에서는 인터페이스와 같은 추상화를 사용해라.

### 추상 클래스와 인터페이스 트레이드오프.

- ### 트레이드오프.
  - 어떤 방식으로 짜든 확실한 정답이 아닐 수 있다.
  - 여러가지 방면으로 트레이드오프를 고민해봐라.

### 코드 재사용.

- ### 상속.
  - 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다.
  - 큰 단점이 2개 존재한다.
    1. 캡슐화를 위반한다.
       - 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.
       - 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
       - 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만든다.
       - 부모 클래스를 변경할 때 자식 클래스도 변경될 확률을 높인다.
    2. 설계를 유연하지 못하게 만든다.
       - 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다.
       - 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
- ### 합성.
  - 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.
  - 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 의미한다.
  - 합성은 상속이 가진 두 가지 문제점을 모두 해결한다.
  - 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 캡슐화할 수 있다.
  - 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만든다.
- ### 정리.
  - 코드 재사용 상황에서 합성이 상속보다 유리하기 때문에 많이 사용된다.
  - 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수밖에 없다.
  
--------------------------------------------------------------------------------

### 최종 정리.
- 객체지향에서 가장 중요한 것은 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.
- 결국 객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 
  <br> 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.















