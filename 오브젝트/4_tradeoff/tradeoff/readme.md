# 4장 설계 품질과 트레이드 오프.

-----------------------------------------------------------------------------------------------

> ## 들어가기.

### 객체지향 설계.
- 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.
    1. 객체지향 설계의 핵심이 책임이다.
    2. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다.

### 훌륭한 설계.
- 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다.
- 적절한 비용 안에서 쉽게 변경할 수 있는 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다.

### 결합도와 응집도를 합리적인 수준으로 유지할 수 있는 원칙.
- 객체의 상태가 아니라 객체의 행동에 초점을 맞춰라.
  - 객체를 단순히 데이터의 집합으로 바라보면 객체의 내부 구현을 퍼블릭 인터페이스에 노출시키는 결과를 낳는다.
  - 이런 문제를 피할 수 있는 가장 좋은 방법은 객체의 책임에 초점을 맞추는 것이다.

-----------------------------------------------------------------------------------------------

> ## 데이터 중심의 영화 예매 시스템.

### 객체지향 설계에서 시스템을 객체로 분할하는 방법.
1. 상태를 분할의 중심축으로 삼는다.
2. 책임을 분할의 중심축으로 삼는다.

### 데이터(상태) 중심의 관점.
- 객체의 상태에 초점을 맞춘다.
- 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다.
- 객체를 독립된 데이터 덩어리로 본다.

### 책임 중심의 관점.
- 객체의 행동에 초점을 맞춘다.
- 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.
- 객체를 협력하는 공동체의 일원으로 본다.

### 책임 중심의 관점을 가져야 하는 이유.
- 객체의 상태는 구현에 속한다.
- 구현은 불안정하기 때문에 변하기 쉽다.
- 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.
- 결과적으로 상태 변경은 인터페이스의 변경을 초래하며 이 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼진다.
- 객체의 책임은 인터페이스에 속한다.
- 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 맞을 수 있따다.

-----------------------------------------------------------------------------------------------

> ## 설계 트레이드오프.

### 이번장 간단한 설명.
- 데이터 중심 설계와 책임 중심 설계의 장단점을 비교하기 위해 캡슐화, 응집도, 결합도를 사용한다.

### 캡슐화.
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다.
- 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 조절할 수 있는 장치를 제공.
- 객체를 사용하면 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개할 수 있다.
- 변경될 가능성이 높은 부분을 구현이라고 부르고 상대적으로 안정적인 부분을 인터페이스라고 부른다.
- 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절해야 된다.
- 설계가 필요한 이유는 요구사항이 변경되기 때문이다.
- 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.
- 정리하면 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.

### 유지보수성.
- 코드를 마음껏 변경할 수 있는 능력을 말한다.
- 유지보수성을 위해 가장 중요한 요소는 캡슐화다.

### 응집도.
- 모듈에 포함된 내부 요소들이 연관돼 있는 정보를 나타낸다.
- 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.
- 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.
- 객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

### 결합도.
- 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.
- 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.
- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.
- 객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

### 일반적인 좋은 설계.
- 일반적으로 좋은 설계는 높은 응집도와 낮은 결합도로 구성된 설계를 의미한다.
- 좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.

### 높은 응집도와 낮은 결합도를 가진 설계.
- 높은 응집도와 낮은 결합도로 설계하는 이유는 설계를 변경하기 쉽게 만들기 때문이다.
- 변경의 관점에서 응집도.
  - 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다.
  - 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높은 것이고 모듈의 일부만 변경된다면 응집도가 낮은 것이다.
  - 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것이다.
  - 응집도가 높을수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다.
- 변경의 관점에서 결합도.
  - 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도.
  - 하나의 모듈을 수정할 때 얼마나 많은 모듈을 함께 수정해야 하는지를 나타낸다.
  - 결합도가 높으면 함께 변경해야 하는 모듈의 수가 늘어나기 때문에 변경하기가 어려워진다.
  - 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우에는 결합도가 높다고 표현한다.
  - 인터페이스에 대해 프로그래밍하라 : 클래스의 구현이 아닌 인터페이스에 의존하도록 코드를 작성해서 결합도를 낮춰라.

### 캡슐화와 응집도, 결합도에 끼치는 영향.
- 캡슐화를 지키면 모듈 안의 응집도는 높아지고 모듈 사이의 결합도는 낮아진다.
- 캡슐화를 위반하면 모듈 안의 응집도는 낮아지고 모듈 사이의 결합도는 높아진다.
- 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력하라.

-----------------------------------------------------------------------------------------------

> ## 데이터 중심의 영화 예매 시스템의 문제점.

### 캡슐화 위반.
- getter, setter 메서드는 캡슐화 원칙을 위반한다.
  - 퍼블릭 인터페이스에 변수를 드러낸다.

### 추측에 의한 설계 전략 design-by-guessing strategy.
- 접근자와 수정자에 과도하게 의존하는 설계 방식을 말한다. (앨런 홀럽)

### 높은 결합도.
- 높은 결합도를 갖는 ReservationAgency는 다른 클래스의 변경이 일어나면 같이 변경해야 되는 단점이 발생한다.

### 낮은 응집도의 문제점.
- 변경의 이유가 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 영향을 받게 된다.
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.

### 단일 책임 원칙 SRP Single Responsibility Principle.
- 클래스는 단 한 가지의 변경 이유만 가져야 한다.
- 클래스의 응집도를 높일 수 있는 설계 원칙.

-----------------------------------------------------------------------------------------------

> ## 자율적인 객체를 향해.

### 접근자, 수정자 사용의 문제점.
1. 코드 중복이 발생할 확률이 높다.
2. 변경에 취약하다.

### 스스로 자신의 데이터를 책임지는 객체.
- 이 객체가 어떤 데이터를 포함해야 하는가 ?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가 ?

-----------------------------------------------------------------------------------------------

> ## 하지만 여전히 부족하다.

### 파급 효과 ripple effect.
- 내부 구현의 변경이 외부로 퍼져나가는 것.
- 캡슐화가 부족하다는 명백한 증거이다.

### 캡슐화의 진정한 의미.
- 변경될 수 있는 어떤 것이라도 감추는 것을 의미한다.
- 내부 속성을 외부로부터 감추는 것은 '데이터 캡슐화'라고 불리는 캡슐화의 한 종류일 뿐이다.

-----------------------------------------------------------------------------------------------

> ## 데이터 중심 설계의 문제점.

### 데이터 중심의 설계가 변경에 취약한 이유.
1. 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
2. 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.
- 데이터 중심의 관점에서 객체는 그저 단순한 데이터의 집합체이기 때문에 getter/setter 메서드를 과도하게 추가하게 된다.
  - getter/setter 메서드를 사용하는 것은 public 변수를 사용하는 것과 큰 차이가 없다. 
- 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 캡슐화를 깨드리기 쉽다.
- 결론적으로 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다.

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.
- 객체지향 애플리케이션을 구현한다는 것은 협력하는 객체들의 공동체를 구축한다는 것을 의미한다.
- 올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.












