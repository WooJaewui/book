
 # operand

operand : 피연산자.


 # 연산자의 구분.

operand의 숫자에 따라 구분한다.

단항연산자 : operand 1개.
이항연산자 : operand 2개.
다항연산자 : operand n개.


 # 연산식( expression )의 특징.

반드시 하나의 값을 산출한다. ( operand나 expression이 아무리 많아도 하나의 값을 산출 )


 # 연산식 우선순위.

1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다. 
    ex ) ++, -- 는 우선순위가 가장 높다.
2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.
3. 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다. ( -> )

일정한 우선순위와 연산 방향이 정해져 있긴 하지만, 다수의 연산식에서는 헷갈릴 수밖에 없기 때문에
복잡한 연산식에서는 ( )를 통해 우선순위를 정해 주는 것이 좋다.


 # 단항연산자.

증감연산자 ( ++, -- )
부호 연산자 ( +, - )
논리 부정 연산자 ( ! )
비트 반전 연산자 ( ~ ) 


 # 증감연산자

i++, ++i는 단항연산자에 사용하면 둘 다, i = i + 1의 역할을 한다.

다항연산자에서 사용하면,

i++ = 10;              10;
++i = 10;              11;

i++은 다른 연산을 수행한 후에 피연산자의 값을 추가하고,
++i는 다른 연산을 수행하기 전에 피연산자의 값을 추가한다. ( 매우매우매우매우 중요 )


 # 증감연산자의 연산 속도.

++i와 i=i+1의 연산 속도는 같다. 
sauce file에서 compiler된 class 파일을 확인해 보면 둘 다 같은 byte code를 가진다.


 # 나머지 단항 연산자들.

논리 부정 연산자 ( ! ) : true/false를 번갈아가며 변경하는 toggle 기능을 구현할 때 주로 사용한다.
비트 반전 연산자 ( ~ ) : 정수의 숫자에서만 사용가능하다. ( int type을 반환한다 ) 


 # 이항연산자.

산술연산자 ( +,-,/,*,% )
문자열 연결연산자 ( + )
대입연산자 ( =, +=, *=, ... )
비교연산자 ( ==, !=, <, ... )
논리연산자 ( &&, ||, ... )
비트논리연산자 ( &, |, ^ )
비트이동연산자 ( <<, >>, >>> )


 # 산술연산자.

1. 크기가 큰 data type으로 자동형변환되어 연산된다. 
 ex ) int + long = long.  ,  float + double = double.

2. int보다 작은 type은 모두 int type으로 변형되어 연산된다.
 ex ) byte + byte = int.

3. 정수 값들의 나눗셈을 실수값에 담았을때, 소수점이 표현이 되지 않기 때문에 소수점 자리에 0을 넣는다.
 ex ) double result = 10 / 4 ;           2.0 반환.

정수타입으로 변환하는 이유는 JVM이 기본적으로 32비트 단위로 계산하기 때문이다.


 # 문자열의 산술연산자.

char는 unicode에 의해 정수로도 표현이 가능하다.
'A' = 65이다.

ex ) 'A' + 1 = 66;       char + int = int


 # 메소드와 변수.

어떠한 data를 신뢰할 만한 사람 또는 내가 입력하지 않고, 다른 사람의 입력을 받아서 사용하는 경우,
method에 조건문 등을 통해 data를 한 번 검사해 주는 것이 좋다.
변수는 신뢰할 만한 data일 경우에만 사용한다.


 # 정확한 data의 계산.

다수의 연산을 통해 정확한 값을 산출해야 되는 경우에는, 연산 과정에서는 정수의 값으로 계산 하는 것이 좋다. 
실수의 값으로 연산할 경우 연산의 과정에서 근사값이 계속 사용되기 때문에 정확한 값을 얻을 수 없다.
꼭 실수를 사용해야 된다면 double을 사용해야 된다.


 # Infinity, NaN.

Infinity : 무한대의 값을 가지는 것이다.                                   ex ) 5/ 0.0      Infinity 반환.  
NaN ( Not a Number ) : 숫자가 아닌 값을 가지는 것이다.            ex ) 5 % 0.0    NaN 반환.

NaN과 Infinity이 나오면 다음 연산을 수행해서는 안된다.
( 어떤 값을 연산하여도 NaN과 Infinity가 나온다 ) 

Double.isInfinity( 변수 ), Double.isNaN( 변수 )와 if문을 통해 제어하자.


 # 비교연산자 주의사항.

char type은 유니코드의 정수의 값으로 비교연산한다. 
실수 type간의 비교연산의 경우 근사값으로 계산하기 때문에 ==이 성립하지 않는다. 


 # equals( ).

equals( ) 메소드는 class에 상황에 따라 조금씩 다르게 사용되고 있기 때문에,
class를 사용할때 equals( ) 메소드를 읽어보고 필요에 따라 override 해서 사용한다.


 # 논리 연산자.

&는 어떤 상황에서라도 피연산자를 모두 확인한다.
&&는 앞에 피연산자가 false라면 뒤에 값에 상관없이 false를 반환하기 때문에 뒤에 피연산자를 확인하지 않는다.

&&값이 훨씬 효율적이기 때문에 &&와 ||를 사용한다.


 # 비트연산자.

비트연산자는 데이터를 비트 단위로 연산하기 때문에, 숫자 중에 정수 타입만 비트연산자를 사용할 수 있다.

A >> N  : A의 값을 2**B만큼 이동. ( A * 2 ** N )
A << N  : A의 값을 2**B만큼 이동. ( A / 2 ** N ) A가 음수 일 때 사용.
A<<< N : A의 값을 2**B만큼 이동. ( A / 2 ** N ) A가 양수 일 때 사용.


 # 삼항연산자.

( boolean ) ? A : B 

boolean = true이면 A값 반환,
boolean = false이면 B값 반환.














