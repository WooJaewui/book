
상속 - 337page.

 # final class.

상속할 수 없는 class를 의미한다. ( 자식 클래스를 만들 수 없다 )


 # final method.

오버라이딩을 할 수 없는 메소드를 의미한다.


 # protected 접근 제어자.

자신의 패키지 + 다른 패키지에 자손 클래스까지 접근가능한 접근 제어자이다.
생성자에 protected가 있는 경우 다른 패키지의 자손 클래스에서 직접 인스턴스를 생성할 수 없고,
super( )를 통해  생성자를 호출할 수 있다.


 # 형변환.

부모타입에 변수에 자식클래스를 대입할 수 있는 성질.
자동형변환 = promotion, 강제형변환 = casting


 # 형변환과 자동 타입 변환 ( Promotion )

부모클래스 변수 = 자식클래스타입 했을때, 자동형변환이 일어난다.
주소 값은 자식클래스에게 되어있고, 형변환이 일어나면서 부모클래스의 멤버가 아닌 값은 사용할 수 없다.
메소드가 오버라이딩 되어 있다면 오버라이딩된 자식의 메소드를 실행한다. ( 매우 중요!! )


 # 필드의 다형성.

부모클래스 변수에 자식클래스를 대입함으로써, 
여러 variable( 필드 )을 한번에 바꿀 수 있는 것이 필드의 다형성이다.
자식클래스에 미리 초기값을 설정해 놓는다.


 # 매개변수의 다형성.

다형성에 의해 매개변수에 부모클래스를 넣고, 인자(argument)로 자식클래스를 대입하여
부모클래스에 존재하는 멤버들의 값을 자식클래스에 멤버값으로 다양하게 사용할 수 있다.


 # 강제 타입 변환 ( Casting )

부모클래스 참조변수에 자식클래스가 자동형변환 되어 있는 경우에 사용가능하다.
자동형변환 된 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 되는 상황이 발생될때 Casting을 사용한다.


 # 객체 타입 확인 instanceOf

참조변수 instanceOf type.
참조변수가 type으로 강제형변환이 가능한지 확인해준다.

강제형변환을 사용하기 전에 항상 instanceOf를 사용해서 확인을 해주는 것이 좋다.
( ClassCastException 예외가 발생함 )


 # 추상클래스 abstract.

자식 클래스들의 공통된 부분을 모아서 만든 클래스이다.
인스턴스를 생성할 수 없다.

추상클래스의 용도.
1. 구현클래스(실체클래스)들의 공통된 필드와 메소드의 이름을 통일.
2. 구현클래스(실체클래스)를 작성할 때 시간을 절약.

구현.
public abstract class ClassName{
          실행할 문장.
}

주의사항.
abstract 메소드가 하나라도 있으면 abstract 클래스이다.
abstract 메소드가 없어도 abstract 클래스일 수 있다.
일반 클래스와 마찬가지로 필드,메소드,생성자를 선언할 수 있다.
직접 생성자를 호출할 수는 없지만, 자식 객체가 생성될때 super( )를 호출함으로 생성자가 반드시 있어야한다.
abstract method가 있다면 자식클래스에서 오버라이딩 해야 된다. 안하면 자식클래스도 abstract가 된다.
자식클래스에서 메소드를 override 할 때 더 작은 범위로 할 수 없다. ( Exception, 제어자 등 )

abstract에 관한 좀 더 자세한 사항은 interface에서 배움.






























