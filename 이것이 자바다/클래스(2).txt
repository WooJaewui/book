클래스(2) - 230page


 # Overloading.

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것이다.
매개변수의 타입, 개수, 순서 중 하나이상 달라야 같은 이름의 메소드를 여러 개 만들 수 있다.
Overload된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다. ( 메소드가 달라야 오버로딩가능 )


 # 정적 멤버와 인스턴스 멤버.

정의.
인스턴스 멤버 : 전역변수와 메소드를 의미한다.
정적 멤버 : static 변수와 static 메소드를 의미한다.

특징.
객체마다 각각 다른 값을 가지는 경우 인스턴스 변수, 같은 값을 가지는 변수를 사용해야 될 경우 static 변수로 만든다.
메소드의 경우에는 어떤 변수를 사용하는지에 따라 static과 instance method가 결정된다. ( static 변수를 하나라도 써야된다면 static method )

사용.
static 멤버를 사용할때는 'ClassName.static멤버'로 사용하는 것이 관례적이다.
instance 멤버를 사용할때는 ClassName c = new ClassName( ); 객체를 생성하고, 'c.instance멤버'로 사용해야 된다. ( 무조건 인스턴스 생성 )


 # 정적 초기화 블록 static block.

필요성.
instance변수들은 생성자를 통해 초기화 할 수 있지만, static 변수들은 생성자를 통해 초기화 할 수 없다.
그래서 계산이 필요한(문장으로 표현해야 하는) static 변수를 초기화 하는 방법이다.

주의사항.
메소드 안에서 사용불가. ( 메소드와 비슷한 역할을 한다 )
인스턴스를 여러개 생성해도 맨 처음 한 번만 초기화한다.
인스턴스 멤버를 사용하려면 블록안에 인스턴스 객체를 생성해야 된다. ( this를 통한 변수 제어 불가 )


 # 싱글톤 ( singleton )

정의.
프로그램 내에서 단 하나의 인스턴스 객체만 만들도록 보장하는 것이다.

원리.
클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다. ( 생성자에 private을 붙인다 )
method를 생성해서 instance가 없을때 객체를 반환하도록 만든다. ( 캡슐화와 관련있다 )

사용.
static className getInstance( ){
       if( instance == null ) 
	   return new className( );
}

주의사항.
멀티쓰레드같은 경우에 동시에 getInstance( ) 를 사용하면 문제가 발생할 수 있다.


 # final 변수.

정의.
프로그램 실행 도중에 수정할 수 없는 변수를 만들때 사용한다. 

초기화.
1. 변수값 선언시 초기화.
2. 생성자에서 초기화.

주의사항.
선언시 초기화하지 않으면, 생성자에서 밖에 초기화가 되지 않는다.
한 번 선언한 후에 다른 값을 대입하는 것은 불가능하다.


 # static final 변수.

정의.
공용성을 띄면서, 도중에 수정하지 않는 변수이다. '상수'라고 불린다.

주의사항.
일반적으로 변수명을 모두 대문자로 사용하고 2개 이상의 단어 사용시 '_'로 구분한다. ( 관례 )


 # 패키지.

정의.
클래스를 체계적으로 관리할 수 있도록 도와주며, 다른 패키지에 같은 클래스명을 가진 클래스들은 모두 다른 클래스로 인식한다.

사용.
package 상위패키지이름.하위패키지이름; 
보통 java파일 제일 위에 작성한다. ( class 밖에 적는다 )

주의사항.
클래스만 복사해서 다른 패키지로 이동하면 사용할 수 없다. 
패키지명은 모두 소문자로 작성하는 것이 관례이다.
cmd에서 컴파일할 경우, javac -d 패키지경로 className.java로 컴파일 해야된다.


 # import문.

정의
다른 package에 있는 class를 사용하려면 package.className으로 인스턴스를 생성해야한다.
이러한 코드의 복잡성을 줄이기 위해 사용하는 것이 import문이다.

사용.
import 상위패키지이름.하위패키지이름.*;
import 상위패키지이름.하위패키지이름.className;
import문의 사용위치는 package 선언과 class사이에 작성한다.

주의사항.
* 표시는 패키지에 속하는 모든 class라는 뜻이다.
import문으로 지정된 패키지의 하위 패키지는 import 대상이 아니다.
하위 패키지에 있는 클래스들도 사용하려면 import문을 하나 더 사용해야된다.
ctrl + shift + o를 통해 자동으로 import문을 작성해준다.


 # 접근 제한자 = 접근 제어자 Access Modifier.

적용대상.
public : 모두사용가능.
protected : 필드, 생성자, 메소드.
default : 모두사용가능.
private : 필드, 생성자, 메소드.

접근할 수 없는 클래스.
public : 없음.
protected : 자식 클래스가 아닌 다른 패키지의 소속된 클래스.
default : 다른 패키지의 클래스. ( 아무것도 적지 않으면 default이다 )
private : 모든 외부 클래스.

클래스의 접근제한.
public : 아무대서나 사용가능.
default : package내에서만 사용가능. ( 아무것도 적지 않으면 default이다 )

생성자의 접근제한.
모든 접근제한자 사용가능.
아무것도 생성하지 않으면 기본생성자를 갖게되고, 기본생성자의 접근제한은 class의 접근제한과 같다.
아무것도 적지 않고 생성자를 코딩하면 default값을 가진다.


 # 캡슐화.

Data의 무결성 ( 결점이 없는 성질 )을 위해 외부 class에서 내부의 variable들을 직접적으로 접근하는 것을 막는것이다.
메소드 안에 if문 등을 통해 data를 검사한 후에 variable의 값을 접근하도록 한다.


 # 어노테이션 Annotation.

정의.
애플리케이션이 처리해야 할 데이터가 아니라, 어떻게 컴파일하고 처리할지 알려주는 정보이다.
'메타데이터'라고도 할 수 있다.

용도.
컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공.
소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보 제공.
실행 시 특정 기능을 실행하도록 정보를 제공.

직접 만들기.
@interface AnnotationName { String element1( ); int element2( ) default 5; }

사용하기.
위에서 만든 AnnotationName을 사용할 경우.
@AnnotationName(element1="value", element2=3);
@AnnotationName(element1="value");

주의사항.
element는 기본형, String, enum, Annotation, class만 허용.
default 값이 없는 elements들은 반드시 값을 대입해야 한다.
Annotation은 인터페이스의 종류 중 하나라고 볼 수 있다.
요소에 지네릭을 정의할 수 없다.

자주사용되는 Annotation은 따로 공부하자!!













