
# 오류처리 

------------------------------------------------------------------------------------------------------------------------

> ## 개요

### 오류 처리의 필요성
- 오류 처리는 프로그램에 반드시 필요한 요소 중 하나이다
- 뭔가 잘 못될 가능성은 늘 존재하고, 뭔가 잘못되면 바로 잡을 책임은 프로그래머에게 있다


### 오류 처리의 중요성
- 깨끗한 코드와 오류 처리는 연관성이 있다
- 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다

------------------------------------------------------------------------------------------------------------------------

> ## 오류 코드보다 예외를 사용하라

### 나쁜 예시 코드
    ...
    public void sendShutDown() {
        DeviceHandle handle = getHandle(DEV1);

        if (handle != DeviceHandle.INVALID) {
            ...

            if (record.getStatus() != DEVICE_SUSPENDED) {
                ...
            }
        }
        ...
    }


### 좋은 예시 코드
    public void sendShutDown() {
        try {
            tryToShutDown();
        } catch (...) {
            ...
        }
    }

    private void tryToShutDown() throws DeviceShutDownError {
        ...
    }
- 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리하였다.

------------------------------------------------------------------------------------------------------------------------

> ## Try-Catch-Finally 문부터 작성하라

### try catch finally로 시작해야 되는 이유
- try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다

------------------------------------------------------------------------------------------------------------------------

> ## 미확인 unchecked 예외를 사용하라

### check 예외 단점
- 메서드 선언부에 throws 절을 추가해야 하는데, 이것은 OCP를 위반한다
- 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다
- 이러한 단점 때문에 특별한 이유가 없다면 unchecked 예외를 사용하자 


### check 예외를 사용해야 하는 시점
- 아주 중요한 라이브러리를 작성한다면 모든 예외를 잡아야 한다

------------------------------------------------------------------------------------------------------------------------

> ## 호출자를 고려해 예외 클래스를 정의하라

### 오류를 정의하는 방법
- 오류를 잡아내는 방법을 기준으로 정의하자

------------------------------------------------------------------------------------------------------------------------

> ## 정상 흐름을 정의하라

### 특수 사례 패턴 SPECIAL PATTERN
- 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
- 클래스나 객체가 예외적인 상황을 캡슐화해서 처리한다
- 이런 방식을 사용하면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다

------------------------------------------------------------------------------------------------------------------------

> ## null을 반환하지 마라

### 나쁜 코드
    if (item != null) { 
        ...
        if (registry != null) {
            ...
        }
    } 
- null을 반환하는 코드는 일거리를 늘리고 호출자에게 문제를 떠넘긴다
- null 확인하는 코드가 많아 코드가 지저분해진다

------------------------------------------------------------------------------------------------------------------------

> ## null을 전달하지 마라

### 나쁜 코드
    public double calculate(Point p1, Point p2) {
        ...
    }

    calculator.calculate(null, new Point(12,13));
- 대다수의 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다
- 그래서, 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다


### 결론
- 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다
- 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다
- 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다







