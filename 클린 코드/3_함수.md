
# 함수

-----------------------------------------------------------------------------------------------------------------------------

> ## 작게 만들어라

### 함수 작성 방식
- 함수는 작게 만드는 것이 좋다


### 코드 길이가 얼마나 짧아야 좋을까?
- if 문 / else 문 / while 문 등에 들어가는 블록은 한 줄이어야 좋다
- 함수에서 들여쓰기 수준은 1단, 2단을 넘어서는 안 된다

-----------------------------------------------------------------------------------------------------------------------------

> ## 한 가지만 해라!

### 함수 작성 방식
- 함수는 한 가지를 해야 한다
- 그 한 가지를 잘 해야 한다
- 그 한 가지만을 해야 한다


### 한 가지만 하는지 판단하는 방법
- 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다

-----------------------------------------------------------------------------------------------------------------------------

> ## 함수 당 추상화 수준은 하나로!

### 함수 작성 방식
- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다


### 추상화 수준 맞추는 방법 : 내려가기 규칙
- 위에서 아래로 프로그램을 읽으면서 함수 추상화 수준이 한 번에 한 단계식 낮아지도록 짠다 (내려가기 규칙)

-----------------------------------------------------------------------------------------------------------------------------

> ## Switch 문

### switch 문 단점
- 함수가 길다
- '한 가지' 작업만 수행하지 않는다
- 단일 책임 원칙 SRP Single Responsibility Principle을 위반한다
- 개방 폐쇄 원칙 OCP Open Closed Principle을 위반한다


### switch 문 작성 
- 일반적으로 다형적 객체를 생성하는 코드 안에서만 사용
- 이외에는 절대로 다른 코드에 노출하지 않는다 (어기는 상황이 꼭 발생한다)

-----------------------------------------------------------------------------------------------------------------------------

> ## 서술적인 이름을 사용하라!

### 좋은 함수 작성 방법
- 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이미 절반은 성공이다


### 서술적인 이름 사용 장점
- 길고 서술적인 이름이 짧고 어려운 이름보다 좋다 
- 서술적인 이름을 사용함녀 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다


### 주의 사항
- 이름을 붙일 때 일관성이 있어야 한다

-----------------------------------------------------------------------------------------------------------------------------

> ## 함수 인수

### 가장 이상적인 함수 인수
- 함수에서 이상적인 인수 개수는 0개(무항)이다
- 인수 개수 3개는 가능한 피하는 편이 좋다
- 인수 4개 이상은 특별한 이유가 필요하다


### 인수가 많을 때 단점
- 함수를 이해하기 어려워진다 (인수에 대한 파악이 필요)
- 테스트를 하기 어려워진다


### 함수에 인수 1개를 넘기는 이유 2가지
1. 인수에 질문을 던지는 경우
    - ex) fileExists("MyFile");
2. 인수를 뭔가로 변환해 결과를 반환하는 경우
    - ex) fileOpen("MyFile);


### 주의 사항
- 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다


### 플래그 인수
- 인수로 boolean 타입을 입력 받는 것을 의미한다
- 플래그 인수는 가급적 사용하지 않는 것이 좋다 (함수가 여러 가지를 처리한다는 것을 의미하기 때문에)


### 이항 인수
- 인수가 2개인 경우
- 단항 인수(인자가 1개인 함수)로 변환할 수 있는지 확인해 본다


### 팁
- 항상 성립하는 코드여도 무시하면 안된다 (무시한 코드에서 오류가 발생한다)


### 삼항 인수
- 인수가 3개인 경우
- 인수 객체로 변환할 것인지 확인해 본다


### 인수 객체
- 인수가 2개 이상 필요한 경우 클래스를 만들 가능성을 짚어본다
- 객체로 생성하면 이름을 붙여야 하므로 개념을 표현하게 된다


### 인수 목록
- 인수 개수가 가변적인 경우
- 가변 인수는 결국 같은 타입의 인수를 받는 경우 List<> 타입의 한 인수를 받은 것으로 생각할 수 있다
- ex) String.format(String format, Object... args)


### 동사
- 단항 함수의 경우 함수와 인수가 동사/명사 쌍을 이루는 것이 좋다
- ex) writeFiled(name);


### 키워드
- 함수 이름에 키워드(인수 이름)을 추가하는 것
- ex) assertExpectedEqualsActual(expected, actual);

-----------------------------------------------------------------------------------------------------------------------------

> ## 부수 효과를 일으키지 마라!

### 부수 효과
- 함수에서 한 가지 이외에 다른 행동을 하는 것을 의미한다

-----------------------------------------------------------------------------------------------------------------------------

> ## 출력 인수

### 출력 인수
- 출력하는 인수를 사용하는 것은 어색하다
- 다른 형태로 바꾸는 것을 생각해봐야 한다


### 예시
    // 변경 전
    appendFooter(StringBuffer report) { ... }

    // 변경 후
    report.appendFooter();
    
-----------------------------------------------------------------------------------------------------------------------------

> ## 명령과 조회를 분리하라!

### CQRS Command and Query Responsibility Segregation
- 읽기, 업데이트 작업을 분리하는 패턴
- 객체 상태를 변경하거나, 객체 정보를 반환하거나 둘 중 하나만 해야 한다


### 분리 했을 때 장점
- 함수 안에서 한 가지 기능만 수행할 수 있다
- 메서드 이름을 지을 때 혼란스럽지 않다

-----------------------------------------------------------------------------------------------------------------------------

> ## 오류 코드보다 예외를 사용하라!

### 오류 코드
- E_OK, ERROR 상수 등과 같이 직접 작성한 오류 상태를 의미한다


### 에외를 반환해야 하는 이유
- 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다
- 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다


### try/catch 블록 뽑아내기
- try/catch 블록은 가독성을 떨어뜨리기 때문에, 별도 함수로 뽑아내는 편이 좋다


### 주의 사항
- 오류 처리도 한 가지 작업이다
- 함수는 한 가지 작업만 처리해야 하므로 오류를 처리하는 함수는 오류만 처리해야 한다

-----------------------------------------------------------------------------------------------------------------------------

> ## 반복하지 마라

### 중복 코드의 단점
- 코드가 길어진다
- 코드의 변경이 필요할 때 중복된 모든 부분에 대해 변경해야 한다

-----------------------------------------------------------------------------------------------------------------------------

> ## 구조적 프로그래밍

### 구조적 프로그래밍 원칙 - 데이크스트라
- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다
- 루프 안에서 break, continue를 사용해서는 안되고 goto는 절대로 안된다 
- 위 규칙은 함수가 매우 클 경우에만 이익을 제공한다


### 팁
- 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다

-----------------------------------------------------------------------------------------------------------------------------

> ## 함수를 어떻게 짜죠?

### 함수 짜는 방식
- 소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다
- 초안은 대게 서투르고 어수선므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다
- 또한, 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스를 만든다 (리팩터링 하더라도 문제 없음을 확인하기 위해)
- 처음부터 완벽한 함수를 짜는 것은 불가능하다


### 도메인 특화 언어 DSL Domain Specific Language
- 특정 분야에 최적화된 특수 프로그래밍 언어
- 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다


### 코드는 이야기이다
- 모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인 특화 언어로 만들어진다
- 함수는 그 언어에서 동사이며, 클래스는 명사다
- 코드를 잘 짜는 프로그래머는 시스템을 도메인 특화 언어를 통해 자신만의 이야기를 풀어간다


### 결론
- 최종 목표는 시스템이라는 이야기를 풀어가는 데 있다
- 함수가 분명하고 정확한 언어로 깔끔해야 이야기를 풀어가기가 쉬워진다























