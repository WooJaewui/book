
 코드에서 나는 악취.



 # 리팩터링을 시작해야 되는 시기.

괴이한 이름 Mysterious Name.
함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지
명확히 알 수 있도록 신경 써서 이름을 지어야 한다.

중복 코드 Duplicated Code.
코드가 비슷하긴 한데 완전히 똑같지는 않다면, 문장 슬라이드하기로 비슷한 부분을 한곳에 모아
함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.

긴 함수 Long Function.
함수 안에서 다른 함수를 호출하는 방식으로 함수를 줄일 수 있다.
요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다.
함수를 호출하는 방식은 함수들의 이름을 잘 지어야 한다는 전제조건이 있다.
무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

긴 매개변수 목록 Long Parameter List.
매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
여러 매개변수를 매개변수 객체로 만들어서 하나로 묶어버린다.

전역 데이터 Golobal Data.
코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제점이다.
변수 캡슐화하기를 통해 리팩터링한다.

가변 데이터 Mutable Data.
변수 캡슐화를 통해 값이 변화할 때 필터역할을 해줄 수 있다.

뒤엉킨 변경 Divergent Change.
하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
맥락이 다른 코드들은 독립된 모듈로 분리해야 프로그래밍이 편하다.

기능 편애 Feature Envy.
모듈화할 때는 영역을 나눈 뒤 영역 안에서 상호작용은 늘리고, 영역 밖에서의 상호작용은 줄인다.

데이터 뭉치 Data Clumps.
여러 클래스에서 자주 함께사용하는 메소드들은 하나의 클래스로 묶어준다.

메시지 체인 Message Chains.
게터 메소드가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나열되는 코드 등을 의미.

내부자 거래 Insider Trading.
모듈 사이의 데이터 거래가 많으면 결합도가 높아지는데, 그 양을 최소로 줄이고 모두 투명하게 처리.
제3의 모듈을 새로 만들어 중간자 역할을 하게 만들 수 있다.

거대한 클래스 Large Class.
클라이언트들이 거대 클래스를 어떻게 이용하는지 패턴을 파악하여 그 클래스를 쪼갤지 단서를 얻음.

주석 Comments.
주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
뭘 할지 모를 때라면 주석을 달아두면 좋다.
진행 상황 및 확실하지 않은 부분에 주석을 남긴다.





