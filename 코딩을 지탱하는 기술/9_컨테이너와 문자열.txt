
 컨테이너와 문자열.
 142 ~ 170page.



 # 왜 다양한 컨테이너가 존재할까 ?

다양한 종류의 컨테이너.
각각의 언어마다 데이터를 넣기 위한 상자가 존재한다. ( 컨테이너 )
같은 용어라도 언어에 따라 다른 의미로 사용되고 있다. 
LISP, Haskell의 리스트와 Java, Python의 리스트는 내부 구조가 완전히 다르다.

배열.
A, B, C라는 변수를 저장하면, 101 - A , 102 - B, 103 - C로 저장된다.
순서대로 연결해서 값을 저장한다.

연결 리스트.
A, B, C라는 변수를 저장하면, 101 - A, 102 - 103( 다음 변수 주소 ), 103 - B, 104 - 105( 다음 변수 주소 ), ...

배열에서 중간에 데이터를 추가하는 경우.
A와 B사이에 D를 추가하면, 102 - D를 추가하고 그 이후에 데이터를 모두 이동( shift )해야된다.
많은 데이터를 저장하는 경우 극심한 성능에 저하가 발생.

연결 리스트에 값을 삽입하는 경우.
A와 B사이에 D를 추가하면, 102 - 200( D의 주소 ), 200 - D하면 된다.
많은 데이터를 저장하고 있어도 똑같이 작업한다.

연결 리스트의 장단점.
장점 - 항목 삽입, 삭제 시 계산량이 항상 일정하다.
단점 - n번째 항목에 있는 요소에 값을 알기 위해 시간이 소요된다.

언어에 따른 차이.
Java, Python, Ruby 등 대부분의 언어에서는 배열이 가장 기본적인 컨테이너로 제공된다.
LISP, Scheme, Haskell 등의 언어에서는 연결 리스트가 가장 기본적인 컨테이너로 제공된다.



 # 사전, 해쉬, 연상 배열.

해쉬 테이블.
키, 값을 저장하여 데이터를 쉽게 검색할 수 있다.
해쉬 함수를 사용해서 키를 적당한 정수로 변환한다. ( 키 해쉬 )
정수에 대응되는 값을 배열에 저장한다. ( 값 저장 )

트리.
나무처럼 위에서 아래로 값에 따라 오른쪽, 왼쪽으로 점점 넓혀나가는 구조를 가진다.
왼쪽 주소, 오른쪽 주소, 키, 값의 구조를 가진다. ( 트리마다 형식이 조금 다를 수 있다 )
현재의 값보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장한다. ( 트리마다 형식이 조금 다를 수 있다 )

요소를 꺼내는 시간.
배열 - 요소 개수가 적으면 유리하다. 일반적으로 해쉬 테이블과 트리에 비해 느리다.
트리 - 100이내에 숫자중에 임의의 값을 알아내는 것과 비슷하다. 배열보다 빠르고 해쉬 테이블보다 느리다.
해쉬 테이블 - 키를 알고 있으면 바로 값을 꺼낼 수 있다.

만능 컨테이너란 없다.
메모리를 절약할 필요가 있는가, 어떤 조작이 많은가, 계산 시간을 줄일 필요가 있는가 등에 따라 선택해서 사용.



 # 문자란 ?

문자 집합과 문자 부호화 방식.
문자는 사람들이 이것을 문자라고 부르자라고 정한 기호 집합이다.
나라나 문화에 따라 다르다.
문자 집합을 디지털 데이터로 표현하는 방식( 부호화 방식 )도 사람이 정한 규칙이다.

컴퓨터 이전 시대의 부호화.
모스 부호 Morse Code 스위치 On/Off를 입력을 통해서 통신했다.

보 코드.
텔레타이프 단말기 - 타자기가 전화선에 연결되어 입력하고 수신자는 문자를 프린터로 출력.
1931년 텔렉스가 발명되어 사용한 부호화 방법이 보 코드 Baudot code이다.
보 코드의 특징은 하나의 문자를 On/Off 5개의 조합( 5비트 )로 표현하는 것이다.
공백, 개행, 회귀 등 제어코드가 문자 세트에 추가되었다.
시프트를 통해 문자열과 숫자를 구분했다.

EDSAC 문자 코드.
1949년 EDSAC이라는 컴퓨터가 발명되었다.
텔렉스와 비슷한 구조로 하나의 열에 5개 구멍을 뚫은 종이 테이프를 입력에 사용했다.

ASCII와 EBCDIC 시대.
American Standard Code for Information Interchage로 정보 교환을 위한 미국 표준 부호이다.
ASCII 한 문자당 7비트를 사용하는 부호화 방식. ( shift가 필요 없어졌다 )
ASCII에는 EDSAC보다 많은 기호와 제어 코드, 그리고 소문자 알파벳도 포함되어 있다.
EBCDIC Extended Binary Coded Decimal Interchange Code로 표시 가능 문자가 ASCII와 거의 같다.

Unicode에 의한 통일.
각 나라마다 자신의 언어를 표현하기 위해 독자 문자 세트를 가지고 있었다.
전 세계의 문자를 부호화하는 방법을 표준화해서 만들자는 움직임에 의해 만들어졌다.
1984년 국제 표준화 기구 ISO에서 UCS Universal Character Set 작업을 시작.
1989년 최초 시안 Unicode Draft 1을 공개.
1993년에 Unicode가 표준이 되었다.



 # 문자열이란 ?

길이 정보가 없는 C , 길이 정보가 있는 Pascal.
C언어와 Pascal은 둘 다 하나의 문자를 8비트로 정의하고 있다.
Pascal 문자열은 제일 앞 부분에 문자열 길이를 기록해둔다는 규칙을 채용.
C 문자열은 문자열이 시작되는 메모리 상의 위치만을 가지고 있다.

NUL 문자로 문자열의 끝을 표현한다.
C언어에서는 선두에서부터 차례대로 읽어서 제일 처음 NUL문자가 나오는 곳까지를 문자열로 인식.

한 문자가 16 비트인 Java 문자열.
자바 문자열도 길이 정보를 가지고 있고, 한 문자( char )가 16비트로 정해져 있다.

Python 3에서 이루어진 설계 변경.
Python은 Java 16비트 문자열과 Pascal 8비트 문자열 모두를 지원하는 언어이다.
"아"라고 쓰면 Unicode 문자열이 되고, b"아"라고 쓰면 바이트열이 되도록 설계.
Unicode 문자열과 바이트열을 결합하면 에러가 발생한다.

Ruby 1.9의 도전.
Ruby 1.9 문자열은 8비트로 하고 부호화 방식 정보를 추가로 보유하도록 만들었다.
Unicode 문자 집합에 포함되지 않는 문자를 손쉽게 쓸 수 있다는 점이 장점이다.

google, apple의 전략.
핸드폰에서 사용하는 그림 문자를 Unicode 문자 집합에 포함시키자고 제안.
Unicode 6.0에서는 수백개의 그림 문자가 추가되었다.

정리.
어떻게 메모리에 저장하느냐에 따라 성능에 차이가 난다.
컨테이너는 각각에 장단점이 존재한다.
언어마다 다른 문자열과 부호화 방식이 존재한다.






