
 다이제스트 인증.
 331 ~ 354page.



 # 다이제스트 인증의 개선점.

다이제스트 인증.
기본 인증의 가장 심각한 결함을 수정한 HTTP 인증 프로토콜.

다이제스트 인증의 특징.
비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
인증 체결을 가로채려는 악의적인 사람들을 차단한다.
구현하기에 따라서 메시지 내용 위조를 막는 것도 가능하다.
그 외 몇몇 잘 알려진 형태의 공격을 막는다.

비밀번호 변경.
비밀번호를 비가역적으로 뒤섞은 지문( fingerprint ) 혹은 요약( digest )을 보낸다.

다이제스트 인증 동작순서.
클라이언트가 서버에게 필요한 서비스를 요청한다.
서버는 클라이언트에게 인증을 요구한다.
클라이언트는 비밀번호의 요약을 서버에게 전달한다.
서버는 자신이 알고 있는 요약과 클라이언트에게 전달받은 요약을 비교해서 확인한다.

MD5.
요약 함수 중 하나로 원래 길이와 상관없이 128비트 요약으로 변환한다.
"Hi" -> C1A581238698129009XNSDJ182
요약 함수는 보통 암호 체크섬( cryptographic checksums )으로 불린다.

난스 nonce 사용.
서버가 클라이언트에게 난스를 건넨다.
난스와 비밀번호를 섞으면 요약이 변경된다.

다이제스트 인증 핸드쉐이크.
서버가 난스를 생성하여 클라이언트에게 전송한다.
클라이언트는 비밀번호와 그 외 데이터에 대한 요약을 계산하여 서버에게 전송한다.
클라이언트가 서버를 인증하길 원한다면 클라이언트에서 난스를 생성해 보낼 수 있다.
서버는 요약을 받고 클라이언트가 했던 그대로 알고리즘을 계산하여 비밀번호를 확인한다.



 # 요약 계산.

보안 관련 데이터 A1.
A1으로 불리는 데이터 덩어리는 비밀 보호 정보로 이루어져 있다.

MD5.
모든 요청마다 단방향 해시를 실행한다.

MD5-sess.
해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스를 붙인 것이 A1이 된다.

메시지 관련 데이터 A2.
본문과 같은 메시지 자체의 정보를 나타낸다.
메소드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.

사전 preemptive 인가.
사용자가 어떤 사이트에 한 번 인증을 하면 Authorization 헤더를 통해 인증하지 않아도 된다.



 # 실제 상황에 대한 고려.

다중 인증요구.
서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.

오류 처리.
요청의 요약이 맞지 않으면 기록해 두는 것이 좋다 - 반복된 실패는 공격자가 있음을 의미할 수도 있다.



 # 보안에 대한 고려사항.

헤더 부당 변경.
헤더 부당 벼경에 대해 안전한 시스템을 제공하기 위해 헤더에 대한 디지털 서명이 필요할 것이다.

재전송 공격.
재전송 공격을 완전히 피할 수 있는 방법은 매 트랜잭션마다 난스 값을 사용하는 것이다.
서버에 부하를 가중시킬 수 있다.

사전 dictionary 공격.
전형적인 비밀번호 추측 공격이다. ( 비밀번호 추측 프로그램 등 )

악의적인 프락시와 중간자 공격.
여러 프락시 중에 보안에 취약한 프락시가 존재한다면 중간자 공격을 당할 수 있다.

선택 평문 공격.
사전 공격 : 자주 쓰이는 비밀번호와 난스를 사전으로 등록하여 공격한다.
무차별 대입 공격 : 가능성 있는 모든 비밀번호를 열거하여 공격한다.




