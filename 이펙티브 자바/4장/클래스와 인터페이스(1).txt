
 클래스와 인터페이스.



 # 클래스와 멤버의 접근 권한을 최소화하라.

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터
얼마나 잘 숨겼느냐다.

정보 은닉의 장점.
- 시스템 개발 속도를 높인다. ( 여러 컴포넌트를 병렬로 개발 )
- 시스템 관리 비용을 낮춘다. ( 디버깅 유리, 컴포넌트 교체 )
- 성능 최적화에 도움을 준다. 
- 소프트웨어 재사용성을 높인다.  
- 큰 시스템을 제작하는 난이도를 낮춰준다. ( 단위 테스트하기 편리하다 )

기본 원칙.
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.

주의사항.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. ( 쓰레드에 안전하지 않다 )

정리.
- 프로그램 요소의 접근성은 가능한 한 최소한으로 해라.
- 꼭 필요한 것만 골라서 public API를 설계하자.



 # public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

원리.
- public 클래스면 필드를 private으로 하고, 접근자 메서드를 사용하라.
- private/default 클래스면 필드를 public으로 해도 된다.



 # 변경 가능성을 최소화하라.

불변 클래스.
- 인스턴스의 내부 값을 수정할 수 없는 클래스다.
- 객체가 파괴되는 순간까지 객체에 저장된 값은 변경되지 않는다.

불변 클래스 사용이유.
- 가변 클래스보다 설계하고 구현하고 사용하기 쉽다.
- 오류가 생길 여지도 적고 훨씬 안전하다.

불변 클래스 규칙.
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

불변 객체의 특징.
- 쓰레드에 안전하여 따로 동기화할 필요 없다.
- 불변 객체를 구성요소로 만들면 이점이 많다. ( Map의 key 또는 Set의 원소로 사용할 수 있다 )
- 그 자체로 실패 원자성을 제공한다.
- 값이 다르면 반드시 독립된 객체로 만들어야 한다.

불변 객체 단점 해결 방법.
1. 흔히 사용될 다단계 연산들을 예측하여 기본 기능으로 제공하는 방법.

상속을 못하게 만드는 방법.
1. private class로 만든다.
2. 모든 생성자를 private으로 만들고 정적 팩터리를 제공한다.

직렬화할 때 주의사항.
- 가변 객체를 참조하는 필드가 있다면 readObject나 readResolve 메서드를 반드시 제공해야 한다. ( 뒤에서 자세히 )

정리.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝낸 상태의 객체를 생성해야 한다.



 # 상속보다는 컴포지션을 사용하라.

원칙.
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.

래퍼클래스의 단점.
- 래퍼 클래스는 단점이 거의 없다.
- 콜백 프레임워크와는 어울리지 않는다. ( 래퍼클래스 내부에 클래스를 참조시켜야 한다 )

정리.
- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
- 상속은 is-a 관계일 때만 사용한다. ( B는 A이다 )
- 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 문제될 수 있다.
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.
- 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.



 # 상속을 고려해 설계하고 문서화하라. 그러지 않았따면 상속을 금지하라.

상속을 고려한 설계와 문서화.
- 메서드를 재정의하면 어떤 일이 일어나느지를 정확히 정리하여 문서로 남겨야 한다.
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.

상속 제약.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.
- Cloneable, Serializable 인터페이스를 구현한 클래스는 상속하지 않는 것이 좋다. ( 확장에 부담이 크다 )

상속을 금지하는 방법.
1. 클래스를 final로 처리.
2. 모든 생성자를 private / default로 처리하고 정적 팩터리ㅡ 사용.
=> 상속을 하기 위해 만든 클래스가 아닌 경우에 사용.

정리.
- 상속용 클래스를 설계하는 것은 쉽지 않다. ( 문서화 작업이 필요 )
- 클래스를 확장할 명확한 이유가 떠오르지 않으면 상속을 금지하는 것이 좋다.



 # 추상 클래스보다는 인터페이스를 우선하라.

인터페이스 장점.
- 기존 클래스에도 손쉽게 인터페이스를 구현해넣을 수 있다.
- 믹스인 정의에 안성맞춤이다.
- 계층구조가 없는 타입 프레임워크를 만들 수 있다.

믹스인 mixin.
- 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.

골격 클래스 주의사항.
- 기반 메서드를 선정한 후 추상 메서드로 작성.
- 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 공유.
- equals / hashCode 같은 Object 메서드는 디폴트 메서드로 제공하면 안된다.

단순 구현.
- 골격 구현과 같이 상속을 위해 인터페이스를 구현할 것이지만, 추상 클래스가 아니란 점이 다르다.
- 쉽게 말해 동작하는 가장 단순한 구현이다.

정리.
- 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 고려해보자.



 # 인터페이스는 구현하는 쪽을 생각해 설계하라.

디폴트 메서드의 문제점.
- 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.
- 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
	=> 디폴트 메소드를 통해 인터페이스를 사용하는 경우 세심한 주의를 기울여야 한다.



 # 인터페이스는 타입을 정의하는 용도로만 사용하라.

설명.
- 인터페이스를 구현하는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것이다.

상수 인터페이스.
- 메서드 없이 static final 변수(상수)로만 이루어진 인터페이스를 의미한다.
- 정규화된 이름을 쓰는 걸 피하기 위해 인터페이스를 구현한다.
- 상수 인터페이스는 안티패턴이다.

상수 인터페이스 단점.
- 상수 인터페이스를 구현하는 것은 내부 구현을 클래스의 API로 노출하는 행위다.
- 클래스가 어떤 상수를 사용하든 사용자는 관심이 없다.
- 상수 인터페이스를 사용하면 종속되게 되고, 구현 클래스가 final이 아닌 경우 상수 인터페이스를 똑같이 상속받는다.

상수를 나타내는 방법.
1. 특정 클래스 내부에 추가해야 한다. ( Integer, Double, ... 등 )
2. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들어 공개한다.

숫자 표현 방법.
- 숫자 리터럴에 '_'을 통해 세자리씩 끊어서 표현할 수 있다. ( 세자리씩 안 끊어도 사용은 가능 )

정리.
- 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.



 # 태그 달린 클래스보다는 클래스 계층구조를 활용하라.

태그 달린 클래스.
- 상태를 표현하는 변수를 가진 클래스를 의미한다.
- 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.
- 클래스 계층구조로 표현하는 것이 훨씬 좋다.

정리.
- 태그 달린 클래스를 써야 하는 상황은 거의 없다.
- 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자.
- 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링하는 걸 고민해보자.



 # 멤버 클래스는 되도록 static으로 만들라.

중첩 클래스.
- 외부 클래스.
	1. 정적 멤버 클래스.
- 내부 클래스.
	1. 비정적 멤버 클래스.
	2. 익명 클래스. 
	3. 지역 클래스.

정적 멤버 클래스.
- 외부 클래스 안에서 선언되고, private 변수를 사용할 수 있다. ( 나머지는 클래스와 같음 )
- 내부 정적 멤버 클래스 private 멤버들은 외부 클래스에서만 사용할 수 있다.

비정적 멤버 클래스.
- 외부 클래스 안에서 선언된다.
- 비정적 멤버 클래스의 메서드를 통해 바깥 인스턴스의 메서드를 호출하거나 참조를 가져올 수 있다.
- 보통 바깥 크래스의 인스턴스 메서드에서 비정적 멤버 클래스의 생성자를 통해 생성하는게 일반적이다.
- 드물게는 바깥 인스턴스.new 비정적 멤버 클래스( )를 통해 생성할 수도 있다.
- 어댑터를 정의할 때 많이 사용된다.

비정적 멤버 클래스의 어댑터.
- 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용.

멤버 클래스.
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.
- static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. ( 가비지 컬렉션이 바깥 인스턴스를 수거하지 못함 )

익명 클래스.
- 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
- 코드의 어디서든 만들 수 있다.
- 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
- 상수, 변수 이외의 정적 멤버는 가질 수 없다.
- 주로 정적 팩터리 메서드를 구현할 때 사용된다. ( 무조건 익명클래스를 쓰는 것은 아님 )

익명 클래스의 단점.
- 선언한 지점에서만 인스턴스를 만들 수 있다.
- instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
- 상속할 수 없다.
- 람다가 나온 후로 많이 사용되지 않음.

지역 클래스.
- 가장 드물게 사용된다.
- 지역변수를 선언할 수 있는 곳이면 어디든지 선언할 수 있다.



 # 톱레벨 클래스는 한 파일에 하나만 담으라.

문제.
- 한 class 파일에 2개의 클래스를 정의했을 때 결과값이 다르게 나오는 문제점이 발생할 수 있다.
- A.java( A, B정의 ) , B.java( A, B정의 ) => A.java를 컴파일 했을때와, B.java를 컴파일 했을때 결과물이 다를 수 있다.

정리.
- 소스 파일 하나에는 반드시 톱레벨 클래스( 인터페이스 )를 하나만 담자.
- 여러개 담으면 컴파일 순서에 따라 다른 결과가 나올 수 있다.





