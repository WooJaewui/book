
 예외.



 # 예외는 진짜 예외 상황에만 사용하라.

예외 특징.
1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다.
	- 최적화에 신경쓰지 않았을 가능성이 크다.
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

예외 사용법.
- 예외는 오직 예외 상황에서만 사용해야 한다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

상태 검사, 옵셔널, 특정 값 중 하나를 선택하는 지침.
1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.
	- 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 

정리.
- 예외는 예외 상황에서 쓸 의도로 설계되었다. 
- 정상적인 제어 흐름에서 사용해서는 안 된다.



 # 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

throwable 타입.
1. 검사 예외. 
2. 런타임 예외.
3. 에러.

throwable 사용 팁.
1. 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
2. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
3. 우리가 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
4. Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다. ( AssertionError는 예외 )
5. Error, Exception, RuntimeException을 상속받지 않는 throwable은 사용하지 말자.

정리.
- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.
- 확실하지 않다면 비검사 예외를 던지자.
- 검사 예외도 아니고, 런타임 예외도 아닌 throwable은 정의하지 말자.
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.



 # 필요 없는 검사 예외 사용은 피하라.

검사 예외를 사용하기 안 좋은 상황.
- 검사 예외를 과하게 사용해서 API를 호출할 때 예외를 처리해야 되는 경우.
- 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다.
- 메서드가 단 하나의 검사 예외만 던지는 경우 피할 수 있는 방법을 찾아봐야 한다.

검사 예외를 대신하는 방법.
1. 검사 예외를 던지는 대신 빈 옵셔널을 반환한다.
	- 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸는 방법.
	- 하나는 상태 값을 Boolean으로 나타내고, 다른 하나는 Boolean값에 따라 로직을 수행하던지, 예외를 처리해준다.

정리.
- 꼭 필요한 곳에만 사용한다면 검사 예외를 프로그램의 안전성을 높여주지만, 남용하면 안 좋은 API가 된다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 옵셔널로 반환해도 될지 고민하자.



 # 표준 예외를 사용하라.

표준 예외의 장점.
1. 내가 만든 API가 다른 사람이 익히고 사용하기 쉬워진다.
2. 예외 클래스가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

주의사항.
- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.
	- 다른 예외들의 상위 클래스이므로, 발생된 예외를 파악하기 어렵다.



 # 추상화 수준에 맞는 예외를 던지라.


























