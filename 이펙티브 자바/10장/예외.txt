
 예외.



 # 예외는 진짜 예외 상황에만 사용하라.

예외 특징.
1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다.
	- 최적화에 신경쓰지 않았을 가능성이 크다.
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다.

예외 사용법.
- 예외는 오직 예외 상황에서만 사용해야 한다.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

상태 검사, 옵셔널, 특정 값 중 하나를 선택하는 지침.
1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다.
3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.
	- 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. 

정리.
- 예외는 예외 상황에서 쓸 의도로 설계되었다. 
- 정상적인 제어 흐름에서 사용해서는 안 된다.



 # 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.

throwable 타입.
1. 검사 예외. 
2. 런타임 예외.
3. 에러.

throwable 사용 팁.
1. 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
2. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
3. 우리가 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.
4. Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다. ( AssertionError는 예외 )
5. Error, Exception, RuntimeException을 상속받지 않는 throwable은 사용하지 말자.

정리.
- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자.
- 확실하지 않다면 비검사 예외를 던지자.
- 검사 예외도 아니고, 런타임 예외도 아닌 throwable은 정의하지 말자.
- 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.



 # 필요 없는 검사 예외 사용은 피하라.

검사 예외를 사용하기 안 좋은 상황.
- 검사 예외를 과하게 사용해서 API를 호출할 때 예외를 처리해야 되는 경우.
- 검사 예외를 던지는 메서드는 스트림 안에서 직접 사용할 수 없다.
- 메서드가 단 하나의 검사 예외만 던지는 경우 피할 수 있는 방법을 찾아봐야 한다.

검사 예외를 대신하는 방법.
1. 검사 예외를 던지는 대신 빈 옵셔널을 반환한다.
	- 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다.
2. 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸는 방법.
	- 하나는 상태 값을 Boolean으로 나타내고, 다른 하나는 Boolean값에 따라 로직을 수행하던지, 예외를 처리해준다.

정리.
- 꼭 필요한 곳에만 사용한다면 검사 예외를 프로그램의 안전성을 높여주지만, 남용하면 안 좋은 API가 된다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.
- 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 옵셔널로 반환해도 될지 고민하자.



 # 표준 예외를 사용하라.

표준 예외의 장점.
1. 내가 만든 API가 다른 사람이 익히고 사용하기 쉬워진다.
2. 예외 클래스가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다.

주의사항.
- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자.
	- 다른 예외들의 상위 클래스이므로, 발생된 예외를 파악하기 어렵다.



 # 추상화 수준에 맞는 예외를 던지라.

예외 번역 exception translation.
- 상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꾸어 던지는 것.

예외 번역 특징.
- 부모 계층에서 하위 계층의 예외가 발생할 경우를 생각해서 하위 계층 예외를 catch문에서 잡아 부모 예외를 발생시켜야 명확해진다.
- cause를 통해 하위 계층 예외를 부모 계층 예외 안에 포함시킬 수 있다.
- 예외를 발생시키지 않는 방법이 최선이다. ( 상위 계층에서 매개변수를 먼저 검사하고 하위 계층으로 값을 보낸다 )

정리.
- 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라.



 # 메세드가 던지는 모든 예외를 문서화하라.

설명.
- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.
- 모든 메서드는 Exception과 같은 상위 Exception으로 예외처리하지 말아야 한다.
- main 메서드는 오직 JVM만이 호출하므로 Exception을 던지도록 선언해도 괜찮다.

자바독 특징.
- @throws에만 명시한 Exception과 @throws, throws 둘 다 적은 Exception을 구분해준다.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 좋다.

정리.
- 메서드가 던질 가는ㅇ성이 있는 모든 예외를 문서화하라.
- 검사 예외만 메서드 선언의 throws 문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말자.



 # 예외의 상세 메시지에 실패 관련 정보를 담으라.

설명.
- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
	- 비밀번호나, 암호 키 등을 담아서는 안된다.
- 예외는 실패와 관련한 정보를 얻을 수 있는 접근자 메서드를 적절히 제공하는 것이 좋다.



 # 가능한 한 실패 원자적으로 만들라.

실패 원자적 failure-amotic.
- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다.

실패 원자적으로 객체를 만들기.
1. 불변 객체로 만든다.
2. 작업 수행에 앞서 매개변수의 유효성을 검사하기.
3. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하기.
4. 객체의 임시 복사본에서 작업을 수행한 다음 작업이 성공적으로 완료되면 원래 객체와 교체하기.
5. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법.

주의사항.
- 실패 원자성은 항상 달성할 수 없다. ( 멀티 쓰레드 환경 등에서 실패할 수 있다 )
- 실패 원자성을 지킬 방법이 있더라도 복잡도가 매우 크면 고려해 봐야 한다.
- 만약 실패 원자적으로 메서드를 작성하지 못했으면, API 설명에 명시해야 한다.



 # 예외를 무시하지 말라.

설명.
- catch 블록을 비워두면 예외가 존재할 이유가 없어진다.
- 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꾸자.



