

 동시성.



 # 공유 중인 가변 데이터는 동기화해 사용하라.

동기화.
- 항상 일관된 상태에서 로직을 수행하게 만들어 준다. ( 로직 수행시 일관된 상태를 변경할 수 있다 )
- 동기화는 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.
- 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
- 읽기와 쓰기 모두를 동기화해야 동작을 보장할 수 있다.

배타적인 실행.
- 상태가 일관되지 않는 객체를 현재 사용중인 쓰레드만 접근이 가능하게 만드는 것을 의미한다.

쓰레드 사이의 안정적인 통신.
- 동기화 없이는 한 쓰레드가 만든 변화를 다른 쓰레드에서 확인하지 못할 수 있다.
- 이런 상황이 발생되지 않게 하는 것을 안정적인 통신이라고 한다.

Thread.
- Thread.stop( )은 deprecated되었다. ( 데이터 손상이 발생할 수 있다 )

volatile.
- Java 변수를 Main Memory에 저장하겠다는 것을 명시하는 것이다.
- 매번 변수의 값을 Read할 때마다 CPU Cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다.
- 변수의 값을 write할 때마다 main Memory에 까지 작성하는 것이다.
- 항상 가장 최근에 기록된 값을 읽게 됨을 보장.

안전 실패 safety failure.
- 프로그램이 잘못된 결과를 계산해내는 오류. ( 동시성 문제 등 )

AutomicLong.
- java.util.concurrent.atomic 패키지에 있는 클래스이다.
- java.util.concurrent.atomic 패키지에는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.

정리.
- 여러 쓰레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다.



 # 과도한 동기화는 피하라.

과도한 동기화.
- 과도한 동기화는 성능을 떨어뜨린다.
- 교착상태를 유발한다.
- 예측할 수 없는 동작을 만들기도 한다.

주의사항.
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블럭 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
- 동기화된 영역 안에서는 재정의할 수 있는 메서드나 클라이언트가 넘겨준 함수 객체를 호출해서는 안 된다.
- 동기화된 영역 안에서 또 다른 동기화 메서드를 호출하면 락이 걸리지 않아 실행할 수 없어 교착상태에 빠질 수 있다.

동기화 기본규칙.
- 동기화 영역에서는 가능한 한 일을 적게 하자.

동기화 성능.
- 락을 얻는 데 드는 CPU의 비용은 그렇게 크지 않다.
- 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 크다.
- 가상 머신의 코드 최적화를 제한한다.

멀티 쓰레드 환경 가변 클래스.
1. 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하자.
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.
	- 단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 2번째를 선택.
	- 항상 동기화를 하기 때문에 성능에 제한이 걸릴 수 있다. ( 외부에서 동기화하는 것이 좋다 )

정리.
- 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.
- 동기화 영역 안에서의 작업은 최소한으로 줄이자.
- 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자.
- 합당한 이유가 있을 때만 내부에서 동기화하고, 동기화 여부를 문서에 남기자.



 # 쓰레드보다는 실행자, 태스트, 스트림을 애용하라.

실행자 서비스의 기능.
- 특정 태스크가 완료되기를 기다린다.
- 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.
- 완료된 태스크들의 결과를 차례로 받는다.
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.

실행자 서비스 사용 특징.
- 작업 큐를 손수 만드는 일은 삼가하고, 스레드를 직접 다루는 것도 일반적으로 삼가해야 한다.
	- 직접 쓰레드를 다루면 쓰레드가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.
	- 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

태스크.
- 작업 단위를 나타내는 추상 개념.
- Runnable과 Callable이 있다. 
	- Callable은 Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다.
- 태스크를 수행하는 일반적인 메커니즘이 실행자 서비스이다.
	- 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 언제든 바꿀 수 있다.

포크조인 태스크.
- 포크조인 풀 실행자 서비스를 통해 실행한다.
- ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있다.
- ForkJoinPool을 구성하는 스레드들이 이 태스크들을 처리하며 일찍 끝나면 다른 태스크를 가져와 대신 처리할 수 있다.



 # wait와 notify보다는 동시성 유틸리티를 애용하라.

java.util.concurretn의 고수준 유틸리티.
1. 실행자 프레임워크.
2. 동시성 컬렉션. ( concurrent collection )
3. 동기화 장치. ( synchronizer )

동시성 컬렉션.
- List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션.
- 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다.
- 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.

동기화 장치.
- 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다.
- 대표적으로 CountDownLatch와 Semaphore가 있다.

CountDownLatch.
- 일회성 장벽으로, 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다.

시간 간격을 잴 때.
- System.currentTimeMillis가 아니라 System.nanoTime을 사용하자. ( 더 정확하다 )
- 시간 측정은 매우 어려운 작업이라 jmh 같은 특수 프레임워크를 사용하는 것이 좋다.

wait notify.
- 새로운 코드라면 언제나 wait와 notify가 아닌 동시성 유틸리티를 써야 한다.
- wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하자. ( 반복문 밖에선느 절대로 호출 X )

조건이 만족되지 않아도 스레드가 깨어나는 상황.
1. 쓰레드가 notify를 호출한 다음 대기 중이던 쓰레드가 깨어나는 사이에 다른 쓰레드가 락을 얻어 그 락이 보호하는 상태를 변경.
2. 조건이 만족되지 않았음에도 다른 쓰레드가 notify를 호출하는 경우.
3. notifyAll을 통해 일부 조건만 만족해도 모든 쓰레드를 깨우는 경우.
4. 허위 각성( spurious wakeup )을 통해 notify없이 일어나는 경우.

정리.
- 코드를 새로 작성한다면 wait와 notifyt를 쓸 이유가 거의 없다.
- wait는 while문 안에서 호출하자.
- notify보다 notifyAll을 사용하자.



 # 쓰레드 안전성 수준을 문서화하라.

쓰레드 안전성.
- 쓰레드 안전성에도 수준이 나뉜다.
- 멀티쓰레드 환경에서도 API를 안전하게 사용하려면 클래스가 지원하는 안전성 수준을 정확히 명시해야 한다.

쓰레드 안전성 순서.
1. 불변.
	- 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다. 
	- String, Long, BigInteger.
2. 무조건적 스레드 안전.
	- 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실한 동기화를 했다.
	- AtomicLong, ConcurrentHashMap.
3. 조건부 스레드 안전.
	- 무조건적 스레드 안전과 같으나, 일부 메서드는 외부 동기화가 필요하다.
	- Collections.synchronized 래퍼 메서드가 반환한 컬렉션들.
4. 스레드 안전하지 않음.
	- 이 클래스의 인스턴스는 수정될 수 있다.
	- 동시에 사용하려면 외부 동기화가 필요하다.
	- ArrayList, HashMap.
5. 쓰레드 적대적.
	- 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티쓰레드 환경에서 안전하지 않다.
	- 동시성을 고려하지 않고 작성하다 보면 우연히 만들어질 수 잇다.
	- 쓰레드 적대적으로 밝혀진 클래스나 메서드는 일반적으로 문제를 고쳐 재배포 또는 deprecated 된다.
	- generateSerialNumber 메서드에서 내부 동기화를 생략하는 경우.

어노테이션.
- @Immutable, @ThreadSafe, @NotThreadSafe 등과 대략 일치한다.
- 무조건적 쓰레드 안전과 조건부 쓰레드 안전은 모두 @ThreadSafe 어노테이션으로 들어간다.

문서화 작성 방법.
- 클래스의 스레드 안전성은 보통 클래스의 문서화 주석에 기재하지만, 특별한 메서드라면 메서드의 주석에 기재하자.
- 반환 타입만으로 정확히 알 수 없는 정적 팩토리라면 자신이 반환하는 객체의 스레드 안전성을 반드시 문서화해야 한다.
- 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 것을 대비해서 비공개 락 객체를 만들자.
	- 락 필드는 항상 final로 만들어라. ( 변화 발생시 문제 발생 )
	- 비공개 락 객체 사용은 무조건적 쓰레드 안전 클래스에서만 사용할 수 있다.
	- 비공개 락 객체 사용은 상속용으로 설계한 클래스에 특히 잘 맞는다. ( 자신을 락으로 사용하면 문제가 발생할 수 있다 )

정리.
- 쓰레드 안전성 정보를 정확히 문서화해야 한다.
- 쓰레드 안전성 정보는 명확히 설명하거나 쓰레드 안전성 어노테이션을 사용할 수 있다.
- synchronized 제어자는 문서화와 관련이 없다.
- 어떤 메서드를 호출할 때 외부 동기화가 가능한 지 등의 정보를 작성해야 한다.
- 무조건적 쓰레드 안전 클래스를 작성할 때는 비공개 락 객체를 사용하자.



 # 지연 초기화는 신중히 사용하라.

지연 초기화 Lazy Initialization.
- 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다.
- 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않는다.
- 정적 필드 인스턴스 필드 모두에 사용할 수 있다.
- 클래스와 인스턴스 초기화 때 발생하는 순환 문제를 해결하는 효과가 있다.
- 클래스와 인스턴스 생성 시 초기화 비용은 줄지만 지연 초기화하는 필드에 접근하는 비용이 커진다.

지연 초기화를 사용하기 좋은 예시.
- 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮고, 필드의 초기화하는 비용이 큰 경우.
	- 명확히 확인하려면 지연 초기화 전/후 성능을 측정해봐야 한다.

주의사항.
- 멀티쓰레드 환경에서는 지연 초기화를 하기가 까다롭다.
- 지연 초기화하는 필드를 둘 이상의 쓰레드가 공유한다면 어떤 형태로든 반드시 동기화해야 한다.
- 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.

사용 팁.
- 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.
- 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하자.
	- 정적 필드에도 이중검사를 사용할 수 있지만 지연 초기화 홀더 클래스가 훨씬 유용하다.
	- 반복해서 초기화해도 상관없는 인스턴스 필드는 두 번째 검사를 생략할 수 있다. ( 단일검사 )

정리.
- 대부분의 필드는 지연시키지 말고 곧바로 초기화해야 한다.
- 성능 또는 초기화 순환을 막기 위해 지연 초기화를 써야 한다면 여러 초기화 기법을 활용하자.
- 인스턴스 필드는 이중 검사, 정적 필드는 지연 초기화 홀더 클래스 관용구를 사용하자.



 # 프로그램의 동작을 스레드 스케쥴러에 기대지 말라.

주의사항.
- 정확성이나 성능이 스레드 스케쥴러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.
- 쓰레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안 된다.
- 쓰레드는 자바에서 이식성이 가장 나쁜 특성에 속한다.

좋은 멀티 쓰레드 프로그램 작성법.
- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것. ( 스케쥴러의 고민이 줄어든다 )

정리.
- 프로그램의 동작을 쓰레드 스케쥴러에 기대지 말자.
- Thread.yield와 스레드 우선순위에 의존하지 말자.





















