
 열거와 이너테이션.



 # int 상수 대신 열거 타입을 사용하라.

열거타입.
- 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입이다.

상수 열거 패턴의 문제점.
- 타입 안전성을 보장할 수 없고, 표현력도 좋지 않다. ( 가독성 )
- 깨지기 쉽다.
- 정수 상수는 문자열로 출력하기가 다소 까다롭다. 
- 디거깅 과정에서 숫자로만 보이기 때문에 어렵다.

열거타입 특징.
- 열거 타입 자체는 클래스이다.
- 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다.
- 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 final이다.
- 열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재한다. ( 싱글톤 )
- 컴파일타임 타입 안전성을 제공한다.
- 열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.

열거 타입에 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
- static에 대한 이해가 필요한데, static은 컴파일 타임에 메모리에 올라간다. ( 재컴파일 하지 않아도 됨 )
- 일반적인 클래스는 런타임에 메모리에 올라간다. ( 재컴파일 해야 함 )

열거 객체.
- 열거 타입의 상수들을 열거 객체를 참조한다.

열거 객체 메소드.
- name( ) : 열거 객체의 문자열을 리턴. ( String )
- oridinal( ) : 열거 객체의 순번을 리턴. ( int )
- compareTo( ) : 열거 객체를 비교해서 순번 차이를 리턴. ( int )
- valueOf( String name ) : 주어진 문자열의 열거 객체를 리턴.
- values( ) : 모든 열거 객체들을 배열로 리턴.

열거 상수와 데이터 매핑.
- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
- 열거 타입은 근본적으로 불변이라 모든 필드는 final이어야 한다. ( public도 가능하지만, 메소드를 따로 두는게 좋다 )

열거 타입 사용 시점.
- 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.

정리.
- 열거 타입은 쉽고 안전하고 강력하다.
- 하나의 메서드가 상수별로 다르게 동작해야 하는 경우 switch 문 대신 상수별 메서드 구현을 사용하자.
- 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자.

참조.
열거타입 특징 : https://splendidlolli.tistory.com/339 , https://kephilab.tistory.com/38
제이온 : https://steady-coding.tistory.com/293
static : https://jinyoungchoi95.tistory.com/16
static : https://mangkyu.tistory.com/47



 # ordinal 메서드 대신 인스턴스 필드를 사용하라.

ordinal 단점.
- 열거 타입에 상수들의 선언이 달라지면 값이 변경된다.

인스턴스 필드 예시.
public enum Enum { 
	A(1), B(2), ...
	
	private final int value;

	Enum( int value ) {
		this.value = value;
	}

}



 # 비트 필드 대신 EnumSet을 사용하라.

EnumSet<E extends Enum<E>>
- 열거 유형에 대한 Set 인터페이스의 특수 구현 중 하나이다.
- Set 인터페이스를 완벽히 구현하며, 타입 안전하고, 다른 어떤 set 구현체와도 함께 사용할 수 있다.
- EnumSet 내부는 비트 벡터로 구현되어있다.
- 원소가 총 64개 이하라면 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.
- new 생성자를 통해 EnumSet을 생성할 수 없다.

메서드.
EnumSet.addOf( Week.class ) : Week Enum을 다루는 Set으로 비어있는 Set을 반환.
EnumSet.nonOf( Week.class ) : 모든 Week Enum의 값을 담고 있는 Set을 반환.

EnumSet를 정적 팩터리 메서드로 만든 이유.
1. 사용자는 어떤 구현 객체가 적합한지 몰라도 상관없다.
2. 사용자는 빈번하게 발생되는 EnumSet 초기화 과정을 간단히 진행할 수 있다.
3. EnumSet의 확장성과 유지보수의 이점이 있다.

출처.
EnumSet : https://siyoon210.tistory.com/152



 # ordinal 인덱싱 대신 EnumMap을 사용하라.

정리.
- 배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.
- Enum.ordinal은 웬만해서는 사용하지 말아야 한다.



 # 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.

정리.
- 열거 타입 자체는 확장할 수 없다.
- 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 확장을 할 수 있다.



 # 명명 패턴보다 애너테이션을 사용하라.

명명 패턴.
- 이름을 일정한 규칙으로 만드는 방법.

명명 패턴의 단점.
- 오타가 나면 안 된다.
- 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다.
- 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다.

메타 애너테이션.
- 애너테이션 선언에 다는 에너테이션.

@Retention( RetentionPolicy.RUNTIME )
- @Test가 런타임에도 유지되어야 한다는 표시.
- 이 메타애너테이션을 생략하면 테스트 도구는 @Test를 인식할 수 없다.

@Target( ElementType.METHOD )
- @Test가 반드시 메서드 선언에서만 사용돼야 된다를 의미.

마커 에너테이션.
- 아무 매개변수 없이 단순히 대상에 마킹한다는 뜻이다.

@Repeatable.
- 한 개의 대상에 한 종류의 애터네이션을 여러번 적용할 수 있게 한다.

@Repeatable 예시코드.
@ExceptionTest( { NullPointException.class, IndexOutOfBoundsException.class } )
public ... ( ) { ... }

정리.
- 일반 프로그래머가 애너테이션 타입을 직접 정의할 일은 거의 없다.
- 자바 프로그래머라면 예외 없이 자바가 제공하는 애너테이션 타입들은 사용해야 한다.



 # @Override 애너테이션을 일관되게 사용하라.

@Override.
- 메서드 선언에만 달 수 있다.
- 상위 타입의 메서드를 재정의했음을 듯한다.
- 애너테이션이 달려 있는데 오버로드에 맞지 않은 형식으로 작성할 경우 Exception을 발생시킨다.
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달자.

예외.
- 구체 클래스에서 상위 클래스의 추상 메서드를 재정의할 떄는 굳이 @Override를 달지 않아도 된다.

정리.
- 재정의한 모든 메서드에 @Override 애너테이션을 달면 코딩을 실수했을 때 컴파일러가 알려줄 것이다.



 # 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.

마커 인터페이스 장점.
1. 마커 인터페이스를 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있느나, 마커 애너테이션은 그렇지 않다.
	- 마커 인터페이스는 타입이기 때문에 컴파일타임에 오류를 잡을 수 있다.
2. 적용 대상을 더 정밀하게 지정할 수 있다.

마커 애너테이션 장점.
- 거대한 애너테이션 시스템의 지원을 받는다. ( 애너테이션 일관성을 위해 사용 )

마커 사용.
- 마커 인터페이스는 클래스와 인터페이스만 사용할 수 있다.
- 마커 애너테이션은 클래스, 인터페이스 이외에도 사용할 수 있다. ( 패키지, 지역변수, 모듈 등 )

정리.
- 마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다.
- 새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자.
- 클래스나 인터페이스 외의 프로그램 요소에 마킹하거나, 애너테이션을 적극 활용하는 프레임워크는 마커 애너테이션을 사용하자.





