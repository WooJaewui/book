
 정리.



 # 제네릭이란??

General Method vs Generic Method.

- 예시코드.
// 1. General Method.

public static void generalMethodName( Box<Object> box ) {
	...
}

// 2. Generic Method.
public static void genericMethodName( Box<T> box ) {
	...
}

=> 차이점 : Box<Object>는 Box<String>, Box<Integer>를 매개변수의 인자로 받을 수 없다. ( Box<Object>만 가능 )



제네릭 타입 vs 와일드 카드.
- 제네릭 타입 <E> or <T>
	- 지금은 무슨 타입인지 모르지만, 타입이 정해지면 그 타입 특성에 맞게 사용하겠다.
	- List<T>라고 가정하고 설명.
		- List에 타입이 뭐가 오든 상관없다.
		- List 인터페이스에 정의되어 있는 기능과 타입 파라미터에 지정된 기능도 사용하겠다.
		- List에 담긴 원소에 대해 알 수 있기 때문에 add( )를 통해 값을 넣을 수 있다.
- 예시코드.
public void methodName( List<E> list ) { 
	list.add( list.get(1) ) ; 	// 가능하다.
	list.add( E ) ; 		// E를 입력할 수 있다면 넣을 수 있다.
}	

- 와일드카드 <?> 
	- 지금도 이 타입을 모르고, 앞으로도 모를 것이다.
	- 원소를 꺼내와서 사용하게 되면 Object에 정의되어 있는 기능만 사용하겠다. ( equals( ), toString( ), ... 등 )
	- List<?> 라고 가정하고 설명.	
		- List에 타입이 뭐가 오든 상관 없다.
		- List에 담긴 원소에 관심이 없기 때문에 add( )를 통해 null만 넣을 수 있다. 
- 예시코드.
public void methodName( List<?> list ) {
	list.add( list.get(1) ) ; 	// 불가능하다.
	list.add( ? ) ; 		// ?의 타입이 정해지더라도 ?를 넣을 수 없다. ( 관심이 없다 )
}

제네릭을 사용할 때.
- 로 타입.
	- List , Set 처럼 제네릭을 아에 작성하지 않는 것이다.
	- 이 방식은 제네릭이 나오기 전에 방식으로 이전 코드와 호환하기 위해 사용한다.
- List<type>
	- 원하는 type을 제네릭 안에 넣는 방식이다.


타입 안전성.
- int a = 10 ; 같이 하나의 변수에는 하나의 타입만 들어갈 수 있었다.
	=> 하나의 변수에 여러가지 타입을 넣자는 생각을 갖게 됨. => Collections( List, Set, Map, ... )
	=> 하나의 변수에 여러가지 타입을 넣으니까 많은 문제가 발생됨. 
	=> Collections에 뭐가 들어있는지 알기 어렵다. ( 사용하기 어렵다 => 타입 안전성이 떨어진다 )
 	=> 타입 안전성을 지키기 위해 제네릭이 나왔다. ( 무슨 타입인지 명시함 )


타입 소거.
- 


실체화 불가 타입.
- E, List<E>, List<String> 같은 타입을 의미한다.
- 실체화 되지 않아서 런 타입에는 컴파일 타임보다 타입 정보를 적게 가지는 타입이다.
- List<?> , List<?, ?>와 같은 비한정적 와일드카드 타입은 실체를 가진다.
	=> 와일드카드는 런타임에 타입이 완벽하게 정해지는 것이 아닌가 ?? 라는 생각을 가지게 됨.


PECS 생성자, 소비자란??











