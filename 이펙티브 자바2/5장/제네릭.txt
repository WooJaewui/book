
 제네릭.



 # 로 타입은 사용하지 말라.

제네릭 클래스/인터페이스.
- 클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 경우. ( <T>, <E>, ... )

제네릭 타입.
- 제네릭 인터페이스 + 제네릭 클래스.

로 타입.
- 제네릭 타입에 아무것도 정의하지 않는 것을 의미한다. ( List, Set, ... )
- 제네릭이 만들어지기 전 코드와 호환되로록 하기 위해 사용된다.

로타입 단점.
- 로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다. ( 호환성 때문에 사용 )
- List<Object>같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안전성을 잃게 된다.

List<Object>
- List<Object>는 List<String>을 대신할 순 없다.

List<?> ( 와일드카드 )
- 지금도 이 타입을 모르고, 앞으로도 모를 것이다.
- 원소를 꺼내와서 Object에 정의되어 있는 기능만 사용하겠다. ( equals( ), toString( ), ... 등 )
- List에 타입이 뭐가 오든 상관 없다.
- List 인터페이스에 정의되어 있는 기능만 사용하겠다. ( size( ), clear( ), ... 등 )
- List에 담긴 원소에 관심이 없기 때문에 add( )를 통해 null만 들어갈 수 있다.

List<T> ( 제네릭 )
- 지금은 이 타입을 모르지만, 이 타입이 정해지면 그 타입 특성에 맞게 사용하겠다.
- List에 타입이 뭐가 오든 상관 없다.
- List 인터페이스에 정의되어 있는 기능과 타입 파라미터에 지정된 기능도 사용하겠다.
- List에 담긴 원소에 대해 알 수 있기 때문에 add( )를 통해 값을 넣을 수 있다.

public void methodName( List<?> list ) { 

	list.add( list.get(1) ) ;

	if( T instanceof String ) { 
		list.add( "hello world" ) ; X
		list.add( null );
	} 

}



출처.
- https://vvshinevv.tistory.com/55 ( 제네릭이란? )
- https://dundung.tistory.com/274 ( 자바 제네릭(Generics) 조금 심화 )

정리.
- 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다.
- List<Objet>는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이다.
- List<?>는 모종의 타입 객체만 저장할 수 있는 와일드카드 타입이다.



 # 비검사 경고를 제거하라.

설명.
- 할 수 있는 한 모든 비검사 경고를 제거하라.
- 모두 제거하면 타입 안전성이 보장된다.
- 경고를 제거할 수는 없지만 타입이 안전하다고 확신할 수 있다면 @SuppressWarnings( "unchecked" )를 달아서 경고를 숨기자.

비검사 경고.
- unchecked를 말하며, casting할 때 검사를 하지 않았다고 뜨는 경고이다.

@SuppressWarnings.
- 항상 가능한 한 좁은 범위에 적용하자.
- @SuppressWarnings 사용해도 안전한 이유를 항상 주석으로 남겨야 한다.

정리.
- 비검사 경고는 중요하니 무시하지 말자.
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하니 최대한 제거하자.
- 비검사 경고를 제거할 수는 없지만 안전함이 증명된 경우 @SuppressWarning을 사용하고 주석을 남기자.



 # 배열보다는 리스트를 사용하라.

배열과 리스트의 차이.
- 배열은 공변이고, 제네릭은 불공변이다.
- 타입이 다른 값을 저장할 경우 배열은 RuntimeException이 발생하고, 리스트는 컴파일 에러가 발생한다.
- 배열은 실체화되고, 제네릭은 컴파일에만 타입을 검사하며 런타임에 타입 정보가 소거( erasure )된다.
- 제네릭은 배열로 만들 수 없다. ( new List<String>[ ] , ... )

실체화 불가 타입.
- E, List<E>, List<String>
- 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.
- 매개변수화 타입 가운데 실체화될 수 있는 타입은 List<?> , Map<?, ?> 같은 비한정적 와일드카드 타입뿐이다.

제네릭을 실체화 불가능하게 만든 이유.
- 제네릭 타입이 런타임에 실체화 된다면 제네릭이 생기기전에 사용했던 클래스들과 호환이 불가능하게 된다.

정리.
- 제네릭은 불공변이고 타입이 소거된다.
- 제네릭과 배열은 서로 반대되는 기능이 존재하기 때문에 같이 사용하기 힘들다.
- 같이 사용하다가 문제가 발생하면 배열을 리스트로 바꾸는 방향으로 사용하자.



 # 이왕이면 제네릭 타입으로 만들라.

배열을 사용하는 코드를 제네릭으로 만들 때 해결방법.
1. 제네릭 배열 생성을 금지하는 제약을 대놓고 우회하는 방법.
	- private E[ ] elements;
	- elements = ( E[ ] ) new Object[10];
	- 타입 안전하지 않다. ( Unchecked Exception이 발생한다 )
	- SuppressWarning을 통해 Unchecked Exception을 제거해준다.
	- 가독성이 뛰어나다.
	- 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염을 일으킨다.
2. elements 필드의 타입을 E[ ] => Object[ ]로 바꾸는 것.
	- private Object[ ] elements;
	- E result = (E) elements[10];
	- 타입 안전하지 않다. ( Unchecked Exception이 발생한다 )
	- SuppressWarning을 통해 Unchecked Exception을 제거해준다.
	- 코드가 1번에 비해 복잡하다.
	- 힙 오염이 발생되지 않는다. ( 런타임 타입 == 컴파일타임 타입 )

Unchecked Exception.
- E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없다.

정리.
- 직접 형변환해야 될 경우 제네릭 타입을 써서 형변환 없이 사용할 수 있도록 만들자.



 # 이왕이면 제네릭 메서드로 만들라.

제네릭 메서드 선언.
- 타입 매개변수에 대한 제네릭 타입은 메서드의 제한자와 반환 타입 사이에 온다.
	- public static <E>(매개변수타입) Set<E>(리턴타입) 메소드이름( Set<E> a1 ) { ... }

재귀 타입 한정 resursive type bound.
- 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있다.
	- public static <E extends Comparable<E>> E max( Collections<E> c ) ;
	- E는 Comparable<E>를 상속해서 서로 비교할 수 있다.

정리.
- 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하고 사용하기 쉽다.



 # 한정적 와일드카드를 사용해 API 유연성을 높이라.

<? extends E>
- E보다 하위 타입의 모든 클래스를 의미한다. ( 자기 자신 포함 )
- 생산자에 사용.

<? super E>
- E보다 상위 타입의 모든 클래스를 의미한다. ( 자기 자신 포함 )
- 소비자에 사용.

PECS Producer-Extends, Consumer-Super.
- 생산자는 <? extends E>, 소비자는 <? super E>.

와일드 카드 사용.
- 유연성을 극대화하려면 원소의 생상자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라.
- 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없다.

주의사항.
- 반환 타입에는 한정적 와일드카드 타입을 사용하면 안 된다.
- 클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 크다.

명시적 타입 인수 explicit type arguments.
- 컴파일러가 올바른 타입을 추론하지 못할 때 타입을 알려주는 방법이다.
	- Set<Number> numbers = Union.<Number>union( integers, doubles ) ;

와일드카드 vs 제네릭 타입.
- 메서드 선언에 타입 매개변수가 한 번만 나오면 와일드 카드로 대체하라.

정리.
- 조금 복잡하더라도 와일드카드 타입을 적용하면 API가 훨씬 유연해진다.
- 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다.
- PECS 공식을 기억하자.
- 생상자는 extends 소비자는 super를 사용한다. ( Comparable, Comparator는 소비자 )



 # 제네릭과 가변인수를 함께 쓸 때는 신중하라.

가변인수 varargs.
- 필요에 따라 매개변수를 가변적으로 조정할 수 있는 기술.
- 제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다. ( 오류가 발생할 수 있다 )

@SafeVarargs.
- 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치다.
- 메서드가 안전한 게 확실할 때만 사용해야 한다.
- 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs를 달아야 한다.

문제점.
- 제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하면 안전하지 않다.

안전한 제네릭 varargs 메서드.
1. varargs 매개변수 배열에 아무것도 저장하지 않는다.
2. 그 배열( 혹은 복제본 )을 신뢰할 수 없는 코드에 노출하지 않는다.

정리.
- 가변인수와 제네릭은 궁합이 좋지 않다.
- 배열과 제네릭의 타입 규칙이 서로 다르기 때문.
- 제네릭 varargs 매개변수를 사용하려면, 타입 안전한지 확인한 다음 @SafeVarargs 애너테이션을 달자.



 # 타입 안전 이종 컨테이너를 고려하자.

예시코드.
private Map<Class<?> , Object> favorites = new HashMap<>();
public <T> void putFavorite( Class<T> type, T instance ) { 
	favorites.put( Objects.requireNonNull( type ), type.cast( instance ) ) ;
}
public <T> T getFavorite( Class<T> type ) { 
	return type.cast( favorites.get( type ) ) ;
}

주의사항.
- 악의적인 클라이언트가 로 타입으로 넘기면 예시코드 타입 안전성이 쉽게 깨진다.
- 실체화 불가 타입에는 사용할 수 없다.

정리.
- 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있다.
- 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있다.
- 타입 안전 이종 컨테이너에 키로 Class를 사용하는데 Class 객체를 타입 토큰이라 한다.



스터디 : https://www.notion.so/yoongeonung/3-E-59cc6558ebd64d9b800e2afbb2975bf2


공부하기.
- 실체화 불가 타입이란??
- PECS에 생성자, 소비자란 ??




