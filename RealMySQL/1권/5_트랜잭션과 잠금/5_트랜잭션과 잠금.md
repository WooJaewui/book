
 # 트랜잭션과 잠금

---------------------------------------------------------------------------------------------------------------------------------------

> ## MySQL에서의 트랜잭션

### 트랜잭션
- 하나의 논리적인 작업 셋에 하나 이상의 쿼리가 100% 적용되거나, 아무것도 적용되지 않아야 함을 보장하는 것이다


### ACID
- 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
- 성질
    - 원자성 Atomicity : 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력
    - 일관성 Consistency : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다
    - 독립성 Isolation : 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들이 못하도록 보장하는 것을 의미
    - 지속성 Durability : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함


### 트랜잭션의 필요성
- 트랜잭션이 없다면 개발할 때, 이전 쿼리의 성공 여부를 조건으로 IF문을 생성해서 다음 쿼리를 수행해야 될 것이다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 주의사항

### 트랜잭션 주의사항
- 트랜잭션의 범위를 최소화하라


### 실제 유의사항
1. DB 커넥션은 개수가 제한적이어서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수가 줄어든다
2. 네트워크를 통한 통신 같은 작업은 트랜잭션 내에서 제거하는 것이 좋다

---------------------------------------------------------------------------------------------------------------------------------------

> ## MySQL 엔진의 잠금

### 잠금 개요
- MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다
- MySQL 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 잠금은 서로 영향을 끼치지 않는다


### 글로벌 락
- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다 (MySQL 서버 전체)
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 DDL, DML을 수행하기 위해서는 대기해야 한다
- 글로벌 락을 걸면 서버에 존재하는 모든 테이블을 닫고 잠금을 건다


### 백업 락
- backup 툴들의 안정적인 실행을 위한 가벼운 글로벌 락
- 테이블의 스키마, 사용자 인증 관련 정보를 변경할 수 없다
  - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
  - REPAIR TABLE과 OPTIMIZE TABLE 명령
  - 사용자 관리 및 비밀번호 변경
- 일반적인 테이블의 변경 허용


### MySQL 서버
- 소스 서버 
- 레플리카 서버
  - 백업이 주로 일어난다


### 테이블 락
- 개별 테이블 단위로 설정하는 잠금이다
- 종류
  - 명시적 테이블 락 
    - LOCK TABLES table_name[READ : WRITE]
  - 묵시적 테이블 락
    - MyISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다
    - 쿼리가 실행되는 동안에 잠금을 하고 완료되면 자동 해제된다


### InnoDB 락
- DML 쿼리에서는 레코드 잠금을 하고, 테이블 락이 무시된다
- 스키마를 변경하는 DDL의 경우 테이블 락이 적용된다


### 네임드 락
    // mylock 문자열에 2초간 잠금
    SELECT GET_LOCK('mylock', 2);

    // mylock 문자열에 잠금 설정 확인
    SELECT IS_FREE_LOCK('mylock');

    // mylock 문자열에 잠금 해제
    SELECT RELEASE_LOCK('mylock');
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다
- 자주 사용되지는 않는다


### 메타데이터 락
- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다
- 테이블의 이름을 변경하는 경우 등에 자동으로 획득하는 잠금이다

---------------------------------------------------------------------------------------------------------------------------------------

> ## InnoDB 스토리지 엔진 잠금

### InnoDB 잠금 개요
- 스토리지 엔진 내ㅑ부에서 레코드 기반의 잠금 방식을 탑재하고 있다
- MySQl 서버의 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS< INNODB_LOCK_WAITS 테이블을 조회하면 InnoDB의 잠금을 확인할 수 있다


### InnoDB 스토리지 엔진의 잠금
- 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 -> 페이지 락 또는 테이블 락으로 레벨업되는 경우는 없다


### 레코드 락 Record lock
- 레코드 자체만을 잠그는 것을 의미한다
- InnoDB 스토리지 레코드 락은 다른 DBMS와 다르게 인덱스의 레코드를 잠근다
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다


### GAP 락
- 레코드와 레코드 사이의 간격을 잠그는 락이다
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 락이다


### 넥스트 키 락 Next Key lock
- 레코드 락과 키 락을 합쳐 놓은 형태의 잠금을 의미한다


### 자동 증가 락
- AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 중복된 숫자가 들어가지 않도록 락을 걸기 위해 사용
- INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다

---------------------------------------------------------------------------------------------------------------------------------------

> ## 인덱스와 잠금

### 인덱스와 레코드 락
- UPDATE 문에서 조회 조건에 원하는 컬럼을 넣어서 작성했을 때, 인덱스가 아닌 경우 해당 레코드와 같은 인덱스를 가진 모든 레코드가 락이 걸린다
- 쿼리를 수행할 때 인덱스를 고려해서 불필요한 레코드 락이 발생하지 않도록 해야 한다

---------------------------------------------------------------------------------------------------------------------------------------

> ## MySQL의 격리 수준

### 트랜잭션 격리 수준 isolation level
- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 결정하는 것
- 종류
  - READ UNCOMMITTED
  - READ COMMITTED
  - REPEATABLE READ
  - SERIALIZABLE


### READ UNCOMMITTED
- 트랜잭션에서의 변경 내용이 COMMIT, ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다
- 데이터 정합성 문제가 많은 격리 수준이기 때문에 잘 사용하지 않는다
- 더티 리드 Dirty read
  - 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

    
### READ COMMITTED
- 오라클 DBMS에서 기본으로 사용되는 격리 수준이다 (온라인 서비스에서 가장 많이 사용)
- 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다
- NON-REPEATABLE READ 부정합 발생 가능
  - 같은 트랜잭션 내에서 같은 SELECT 쿼리를 수행하는 데 다른 트랜잭션에서 중간에 UPDATE가 발생하거나 하면 다른 조회 결과를 반환하는 경우
  - 일반적인 웹 프로그램에서는 문제가 되지 않지만, 금전적인 처리와 연결되면 문제가 될 수 있다


### REPEATABLE READ
- InnoDB 스토리지 엔진에서 기본으로 상요되는 격리 수준이다
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다
- NON_REPEATABLE READ 부정합이 발생하지 않는다
- MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다
- PHANTOM READ 문제
  - SELECT ... FOR UPDATE 쿼리는 SELECT 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다 
  - SELECT ... FOR UPDATE, SELECT ... LOCK IN SHARE MODE 로 조회하는 레코드는 언두 영역의 데이터를 가져올 수 없다


### SERIALIZABLE
- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다
- 읽기 작업도 읽기 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 절대 접근할 수 없다
- PHANTOM READ 문제가 발생하지 않는다



















